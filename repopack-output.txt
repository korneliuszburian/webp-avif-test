================================================================
Repopack Output File
================================================================

This file was generated by Repopack on: 2025-03-20T15:03:20.328Z

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This header section
2. Repository structure
3. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
1. This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
2. When processing this file, use the separators and "File:" markers to
  distinguish between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.



For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
.github/
  workflows/
    main.yml
    permissions.yml
    simple-build.yml
assets/
  css/
    admin.css
  js/
    admin.js
bin/
  fix-code-style.sh
  install-git-hooks.sh
config/
  services.php
src/
  Admin/
    AdminPage.php
    DashboardWidget.php
  Conversion/
    AvifConverter.php
    ConverterInterface.php
    WebpConverter.php
  Core/
    Container.php
    Plugin.php
    Settings.php
  Frontend/
    ImageDelivery.php
  Media/
    MediaLibraryIntegration.php
    MediaProcessor.php
  Utility/
    Logger.php
    ProgressManager.php
    Stats.php
  Autoloader.php
.distignore
.htaccess
CHANGELOG.md
composer.json
index.php
phpcs.xml.dist
phpstan.neon
README.md
uninstall.php
wp-image-optimizer.php

================================================================
Repository Files
================================================================

================
File: .github/workflows/main.yml
================
name: Build & Deploy WordPress Plugin

on:
  push:
    branches: [ main ]
    tags:
      - 'v*.*.*'
  pull_request:
    branches: [ main ]

# Set permissions for GitHub token
permissions:
  contents: write    # This is required for actions/checkout and creating releases
  packages: write    # This is required for publishing packages

jobs:
  validate:
    name: Validate & Test
    runs-on: ubuntu-latest
    strategy:
      matrix:
        php-versions: ['8.1', '8.2', '8.3']
        wordpress-versions: ['6.0', '6.1', '6.2', 'latest']
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup PHP
        uses: shivammathur/setup-php@v2
        with:
          php-version: ${{ matrix.php-versions }}
          extensions: gd, imagick, mbstring
          tools: composer:v2
          coverage: none
        
      - name: Check for composer.json
        id: check_composer
        run: |
          if [ -f "composer.json" ]; then
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Install Composer dependencies
        if: steps.check_composer.outputs.exists == 'true'
        run: |
          composer install --no-progress --prefer-dist --optimize-autoloader

      - name: PHP Syntax Check
        run: |
          find . -type f -name "*.php" -not -path "./vendor/*" -print0 | xargs -0 -n1 php -l

      - name: Code Quality & Security Checks
        if: ${{ matrix.php-versions == '8.1' && matrix.wordpress-versions == 'latest' && steps.check_composer.outputs.exists == 'true' }}
        run: |
          composer require --dev squizlabs/php_codesniffer wp-coding-standards/wpcs dealerdirect/phpcodesniffer-composer-installer phpstan/phpstan phpcompatibility/php-compatibility
          
          echo "Running PHP CodeSniffer..."
          vendor/bin/phpcs --standard=phpcs.xml.dist --extensions=php .
          
          echo "Running PHPStan..."
          vendor/bin/phpstan analyse --no-progress --level=3 src/
          
          echo "Running Security Checks..."
          vendor/bin/phpcs --standard=PHPCompatibility,PSR12 --extensions=php --runtime-set testVersion 8.1- src/
        continue-on-error: true  # Report issues but don't fail the build

  build:
    name: Build Plugin Package
    needs: validate
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/')
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Get the version
        id: get_version
        run: echo "VERSION=${GITHUB_REF#refs/tags/v}" >> $GITHUB_OUTPUT

      - name: Setup PHP
        uses: shivammathur/setup-php@v2
        with:
          php-version: '8.1'
          extensions: gd, imagick, mbstring
          tools: composer:v2
          coverage: none

      - name: Check for composer.json
        id: check_composer_build
        run: |
          if [ -f "composer.json" ]; then
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Install Composer dependencies
        if: steps.check_composer_build.outputs.exists == 'true'
        run: |
          composer install --no-dev --no-progress --prefer-dist --optimize-autoloader

      - name: Create build directory
        run: |
          mkdir -p build/wp-image-optimizer

      - name: Copy files to build directory
        run: |
          rsync -av --exclude-from='.distignore' --exclude='.git/' --exclude='.github/' --exclude='build/' --exclude='node_modules/' . build/wp-image-optimizer/

      - name: Create plugin zip
        run: |
          cd build
          zip -r wp-image-optimizer-${{ steps.get_version.outputs.VERSION }}.zip wp-image-optimizer

      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          files: ./build/wp-image-optimizer-${{ steps.get_version.outputs.VERSION }}.zip
          name: Release ${{ steps.get_version.outputs.VERSION }}
          body: |
            ## WebP & AVIF Image Optimizer ${{ steps.get_version.outputs.VERSION }}
            
            See [CHANGELOG.md](CHANGELOG.md) for details.

  deploy-wp-org:
    name: Deploy to WordPress.org
    needs: build
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/')
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: WordPress Plugin Deploy
        uses: 10up/action-wordpress-plugin-deploy@stable
        env:
          SVN_PASSWORD: ${{ secrets.SVN_PASSWORD }}
          SVN_USERNAME: ${{ secrets.SVN_USERNAME }}
          SLUG: wp-image-optimizer

================
File: .github/workflows/permissions.yml
================
name: Update Workflow Permissions

on:
  workflow_dispatch:

permissions:
  contents: write
  packages: write

jobs:
  update-permissions:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        
      - name: Update workflow permissions
        run: echo "This workflow exists solely to set the appropriate permissions for GitHub Actions"

================
File: .github/workflows/simple-build.yml
================
name: Simple Build & Deploy

on:
  push:
    branches: [ main ]
    tags:
      - 'v*.*.*'
  pull_request:
    branches: [ main ]

# Set permissions for GitHub token
permissions:
  contents: write    # This is required for actions/checkout and creating releases
  packages: write    # This is required for publishing packages

jobs:
  validate:
    name: Validate Code
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup PHP
        uses: shivammathur/setup-php@v2
        with:
          php-version: '8.1'
          extensions: gd, imagick, mbstring
          coverage: none
        
      - name: PHP Syntax Check
        run: |
          find . -type f -name "*.php" -print0 | xargs -0 -n1 php -l

  build-release:
    name: Build Release Package
    needs: validate
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/')
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Get the version
        id: get_version
        run: echo "VERSION=${GITHUB_REF#refs/tags/v}" >> $GITHUB_OUTPUT

      - name: Create build directory
        run: |
          mkdir -p build/wp-image-optimizer

      - name: Copy files to build directory
        run: |
          rsync -av --exclude='.git/' --exclude='.github/' --exclude='build/' . build/wp-image-optimizer/

      - name: Create plugin zip
        run: |
          cd build
          zip -r wp-image-optimizer-${{ steps.get_version.outputs.VERSION }}.zip wp-image-optimizer

      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          files: ./build/wp-image-optimizer-${{ steps.get_version.outputs.VERSION }}.zip
          name: Release ${{ steps.get_version.outputs.VERSION }}
          body: |
            ## WebP & AVIF Image Optimizer ${{ steps.get_version.outputs.VERSION }}
            
            See [CHANGELOG.md](CHANGELOG.md) for details.

================
File: assets/css/admin.css
================
/**
 * WordPress WebP & AVIF Optimizer admin styles
 */

/* Settings page styles */
.wp-image-optimizer-range-field {
    display: flex;
    align-items: center;
    margin-bottom: 5px;
}

.wp-image-optimizer-range-value {
    margin-left: 10px;
    min-width: 30px;
    font-weight: bold;
}

/* Progress bar styles */
.wp-image-optimizer-progress-wrapper {
    margin: 20px 0;
    max-width: 600px;
}

.wp-image-optimizer-progress {
    height: 25px;
    background-color: #f0f0f0;
    border-radius: 3px;
    margin-bottom: 5px;
    overflow: hidden;
    box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
}

.wp-image-optimizer-progress-bar {
    height: 100%;
    background-color: #2271b1;
    width: 0%;
    transition: width 0.3s ease;
}

.wp-image-optimizer-progress-text {
    display: flex;
    justify-content: space-between;
    font-size: 12px;
    color: #666;
}

/* Statistics styles */
.wp-image-optimizer-statistics table {
    max-width: 800px;
    margin-top: 20px;
}

/* Media library integration */
.wp-image-optimizer-buttons {
    margin-top: 10px;
}

.wp-image-optimizer-status {
    margin-bottom: 8px;
}

.wp-image-optimizer-webp, 
.wp-image-optimizer-avif {
    display: inline-block;
    margin-right: 15px;
}

.wp-image-optimizer-convert {
    display: flex !important;
    align-items: center;
    justify-content: center;
}

.wp-image-optimizer-convert .spinner {
    float: none;
    margin-top: 0;
    margin-right: 5px;
}

/* Dashboard widget */
.wp-image-optimizer-dashboard-widget .inside {
    padding: 0;
    margin: 0;
}

.wp-image-optimizer-dashboard-stats {
    display: flex;
    flex-wrap: wrap;
    justify-content: space-between;
}

.wp-image-optimizer-stat-box {
    box-sizing: border-box;
    width: 48%;
    background: #f9f9f9;
    border: 1px solid #e5e5e5;
    padding: 15px;
    margin-bottom: 15px;
    text-align: center;
}

.wp-image-optimizer-stat-label {
    display: block;
    font-size: 13px;
    margin-bottom: 5px;
    color: #777;
}

.wp-image-optimizer-stat-value {
    display: block;
    font-size: 18px;
    font-weight: 600;
    color: #23282d;
}

.wp-image-optimizer-dashboard-actions {
    padding: 15px;
    margin-top: 10px;
    border-top: 1px solid #eee;
}

================
File: assets/js/admin.js
================
/**
 * WordPress WebP & AVIF Optimizer admin scripts
 */
(function($) {
    'use strict';
    
    // Bulk conversion handler
    function initBulkConversion() {
        const $button = $('.wp-image-optimizer-bulk-convert');
        const $progress = $('.wp-image-optimizer-progress-wrapper');
        const $progressBar = $('.wp-image-optimizer-progress-bar');
        const $progressText = $('.wp-image-optimizer-progress-percentage');
        const $progressCount = $('.wp-image-optimizer-progress-count');
        
        let processId = '';
        let total = 0;
        let intervalId = null;
        
        $button.on('click', function() {
            $(this).prop('disabled', true).text('Processing...');
            $progress.show();
            
            // Start bulk conversion
            $.ajax({
                url: wpImageOptimizer.ajax_url,
                type: 'POST',
                data: {
                    action: 'wp_image_optimizer_bulk_convert',
                    nonce: wpImageOptimizer.nonce
                },
                success: function(response) {
                    if (response.success) {
                        processId = response.data.process_id;
                        total = response.data.total;
                        
                        // Start progress polling
                        intervalId = setInterval(pollProgress, 1000);
                    } else {
                        handleError(response.data.message);
                    }
                },
                error: function() {
                    handleError('Ajax request failed');
                }
            });
        });
        
        function pollProgress() {
            $.ajax({
                url: wpImageOptimizer.ajax_url,
                type: 'POST',
                data: {
                    action: 'wp_image_optimizer_get_progress',
                    nonce: wpImageOptimizer.nonce,
                    process_id: processId
                },
                success: function(response) {
                    if (response.success) {
                        updateProgress(response.data);
                        
                        // Check if process is complete
                        if (response.data.processed >= total) {
                            clearInterval(intervalId);
                            $button.text('Conversion Complete').removeClass('button-primary');
                            
                            // Reload after 2 seconds to update statistics
                            setTimeout(function() {
                                window.location.reload();
                            }, 2000);
                        }
                    } else {
                        handleError(response.data.message);
                    }
                },
                error: function() {
                    handleError('Ajax request failed');
                }
            });
        }
        
        function updateProgress(data) {
            const percentage = data.percentage;
            const processed = data.processed;
            
            $progressBar.css('width', percentage + '%');
            $progressText.text(percentage + '%');
            $progressCount.text('(' + processed + '/' + total + ')');
        }
        
        function handleError(message) {
            clearInterval(intervalId);
            $button.prop('disabled', false).text('Retry Conversion');
            alert('Error: ' + message);
        }
    }
    
    // Media library conversion button
    function initMediaLibraryButtons() {
        $(document).on('click', '.wp-image-optimizer-convert', function() {
            const $button = $(this);
            const attachmentId = $button.data('id');
            const $spinner = $button.find('.spinner');
            
            $button.prop('disabled', true);
            $spinner.addClass('is-active');
            
            $.ajax({
                url: wpImageOptimizer.ajax_url,
                type: 'POST',
                data: {
                    action: 'wp_image_optimizer_convert_single',
                    nonce: wpImageOptimizer.nonce,
                    attachment_id: attachmentId
                },
                success: function(response) {
                    $spinner.removeClass('is-active');
                    
                    if (response.success) {
                        $button.text(wpImageOptimizer.i18n.converted);
                        
                        // Update status indicators
                        const $webpStatus = $button.closest('.wp-image-optimizer-buttons').find('.wp-image-optimizer-webp .dashicons');
                        const $avifStatus = $button.closest('.wp-image-optimizer-buttons').find('.wp-image-optimizer-avif .dashicons');
                        
                        if (response.data.webp) {
                            $webpStatus.removeClass('dashicons-no').addClass('dashicons-yes').css('color', 'green');
                        }
                        
                        if (response.data.avif) {
                            $avifStatus.removeClass('dashicons-no').addClass('dashicons-yes').css('color', 'green');
                        }
                    } else {
                        $button.text(wpImageOptimizer.i18n.error);
                        setTimeout(function() {
                            $button.prop('disabled', false).text(wpImageOptimizer.i18n.convert);
                        }, 2000);
                    }
                },
                error: function() {
                    $spinner.removeClass('is-active');
                    $button.text(wpImageOptimizer.i18n.error);
                    setTimeout(function() {
                        $button.prop('disabled', false).text(wpImageOptimizer.i18n.convert);
                    }, 2000);
                }
            });
        });
    }
    
    // Initialize on document ready
    $(function() {
        if ($('.wp-image-optimizer-bulk').length) {
            initBulkConversion();
        }
        
        initMediaLibraryButtons();
    });
    
})(jQuery);

================
File: bin/fix-code-style.sh
================
#!/bin/bash

# Script to fix common coding standards issues

# Make sure we're in the root directory of the project
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )"
ROOT_DIR="$(dirname "$SCRIPT_DIR")"
cd "$ROOT_DIR" || exit 1

echo "Fixing coding standards issues..."

# Run PHP Code Beautifier and Fixer if available
if [ -f vendor/bin/phpcbf ]; then
  echo "Running PHP Code Beautifier and Fixer..."
  vendor/bin/phpcbf --standard=phpcs.xml.dist --extensions=php .
fi

# Fix PHP file permissions
echo "Setting correct file permissions..."
find . -type f -name "*.php" -exec chmod 644 {} \;

# Ensure files use LF line endings
echo "Converting to LF line endings..."
find . -type f -name "*.php" -exec dos2unix -k {} \; 2>/dev/null || echo "dos2unix not installed, skipping line ending conversion"

echo "Done! Some issues may require manual fixing."
echo "To see remaining issues, run: composer phpcs"

================
File: bin/install-git-hooks.sh
================
#!/bin/bash

# Script to install git hooks

# Make sure we're in the root directory of the project
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )"
ROOT_DIR="$(dirname "$SCRIPT_DIR")"
cd "$ROOT_DIR" || exit 1

# Create pre-commit hook if it doesn't exist
if [ ! -f .git/hooks/pre-commit ]; then
  cat > .git/hooks/pre-commit << 'EOF'
#!/bin/bash

# Get a list of staged PHP files
STAGED_PHP_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep '\.php$')

# Exit if there are no PHP files staged
if [ -z "$STAGED_PHP_FILES" ]; then
  exit 0
fi

echo "Running pre-commit checks..."

# Run PHP lint on each file
for FILE in $STAGED_PHP_FILES; do
  php -l "$FILE" > /dev/null 2>&1
  if [ $? -ne 0 ]; then
    echo "PHP syntax error in $FILE. Please fix before committing."
    exit 1
  fi
done

# Only run PHP syntax checks as a required pre-commit check
# Display other checks as warnings but don't block the commit

# Run PHPCS if available (but don't fail the commit)
if [ -f vendor/bin/phpcs ]; then
  echo "Running PHP CodeSniffer (informational only)..."
  vendor/bin/phpcs --standard=phpcs.xml.dist $STAGED_PHP_FILES
  if [ $? -ne 0 ]; then
    echo "⚠️ PHPCS found style issues. Consider running 'composer fix' or './bin/fix-code-style.sh'"
    echo "You can still commit, but these issues might cause CI checks to fail."
  fi
fi

# Run PHPStan if available (but don't fail the commit)
if [ -f vendor/bin/phpstan ]; then
  echo "Running PHPStan (informational only)..."
  vendor/bin/phpstan analyse $STAGED_PHP_FILES
  if [ $? -ne 0 ]; then
    echo "⚠️ PHPStan found potential issues."
    echo "You can still commit, but these issues might cause CI checks to fail."
  fi
fi

# Run security checks if available (but don't fail the commit)
if [ -f vendor/bin/phpcs ]; then
  echo "Running security checks (informational only)..."
  vendor/bin/phpcs --standard=PHPCompatibility --extensions=php --runtime-set testVersion 8.1- $STAGED_PHP_FILES
  if [ $? -ne 0 ]; then
    echo "⚠️ Security checks found potential issues."
    echo "You can still commit, but these issues might cause CI checks to fail."
  fi
fi

echo "All pre-commit checks passed!"
exit 0
EOF

  # Make hook executable
  chmod +x .git/hooks/pre-commit
  echo "Git pre-commit hook installed successfully"
else
  echo "Git pre-commit hook already exists"
fi

================
File: config/services.php
================
<?php

/**
 * Service definitions for dependency injection container
 */

// Core services
$container->set(
	'plugin',
	function ( $c ) {
		return new \WpImageOptimizer\Core\Plugin( $c );
	}
);

$container->set(
	'settings',
	function ( $c ) {
		return new \WpImageOptimizer\Core\Settings();
	}
);

// Utility services
$container->set(
	'logger',
	function ( $c ) {
		return new \WpImageOptimizer\Utility\Logger();
	}
);

$container->set(
	'progress_manager',
	function ( $c ) {
		return new \WpImageOptimizer\Utility\ProgressManager();
	}
);

$container->set(
	'stats',
	function ( $c ) {
		return new \WpImageOptimizer\Utility\Stats();
	}
);

// Converters
$container->set(
	'webp_converter',
	function ( $c ) {
		return new \WpImageOptimizer\Conversion\WebpConverter(
			$c->get( 'settings' ),
			$c->get( 'logger' )
		);
	}
);

$container->set(
	'avif_converter',
	function ( $c ) {
		return new \WpImageOptimizer\Conversion\AvifConverter(
			$c->get( 'settings' ),
			$c->get( 'logger' )
		);
	}
);

// Media services
$container->set(
	'media_processor',
	function ( $c ) {
		return new \WpImageOptimizer\Media\MediaProcessor(
			$c->get( 'webp_converter' ),
			$c->get( 'avif_converter' ),
			$c->get( 'settings' ),
			$c->get( 'progress_manager' ),
			$c->get( 'logger' )
		);
	}
);

$container->set(
	'media_library_integration',
	function ( $c ) {
		return new \WpImageOptimizer\Media\MediaLibraryIntegration(
			$c->get( 'settings' ),
			$c->get( 'media_processor' )
		);
	}
);

// Admin services
$container->set(
	'admin_page',
	function ( $c ) {
		return new \WpImageOptimizer\Admin\AdminPage(
			$c->get( 'settings' ),
			$c->get( 'stats' ),
			$c->get( 'logger' ),
			$c->get( 'progress_manager' )
		);
	}
);

$container->set(
	'dashboard_widget',
	function ( $c ) {
		return new \WpImageOptimizer\Admin\DashboardWidget(
			$c->get( 'stats' )
		);
	}
);

// Frontend services
$container->set(
	'image_delivery',
	function ( $c ) {
		return new \WpImageOptimizer\Frontend\ImageDelivery(
			$c->get( 'settings' )
		);
	}
);

================
File: src/Admin/AdminPage.php
================
<?php

namespace WpImageOptimizer\Admin;

use WpImageOptimizer\Core\Settings;
use WpImageOptimizer\Utility\Stats;
use WpImageOptimizer\Utility\Logger;
use WpImageOptimizer\Utility\ProgressManager;

class AdminPage {
	public function __construct(
		private Settings $settings,
		private Stats $stats,
		private Logger $logger,
		private ProgressManager $progressManager
	) {}

	/**
	 * Register hooks for admin page
	 */
	public function registerHooks(): void {
		add_action( 'admin_menu', array( $this, 'addMenuPages' ) );
		add_action( 'admin_init', array( $this, 'registerSettings' ) );
		add_action( 'admin_enqueue_scripts', array( $this, 'enqueueAssets' ) );

		// Ajax handlers
		add_action( 'wp_ajax_wp_image_optimizer_get_progress', array( $this, 'ajaxGetProgress' ) );
		add_action( 'wp_ajax_wp_image_optimizer_convert_single', array( $this, 'ajaxConvertSingle' ) );
		add_action( 'wp_ajax_wp_image_optimizer_bulk_convert', array( $this, 'ajaxBulkConvert' ) );
	}

	/**
	 * Add menu pages
	 */
	public function addMenuPages(): void {
		add_options_page(
			__( 'WebP & AVIF Optimizer', 'wp-image-optimizer' ),
			__( 'WebP & AVIF', 'wp-image-optimizer' ),
			'manage_options',
			'wp-image-optimizer',
			array( $this, 'renderSettingsPage' )
		);
	}

	/**
	 * Register settings
	 */
	public function registerSettings(): void {
		register_setting( 'wp_image_optimizer_settings', 'wp_image_optimizer_settings' );

		// General settings section
		add_settings_section(
			'wp_image_optimizer_general',
			__( 'General Settings', 'wp-image-optimizer' ),
			array( $this, 'renderGeneralSection' ),
			'wp_image_optimizer'
		);

		// Add settings fields
		add_settings_field(
			'wp_image_optimizer_auto_convert',
			__( 'Auto Convert on Upload', 'wp-image-optimizer' ),
			array( $this, 'renderCheckboxField' ),
			'wp_image_optimizer',
			'wp_image_optimizer_general',
			array(
				'id'          => 'auto_convert',
				'description' => __( 'Automatically convert images to WebP and AVIF when they are uploaded', 'wp-image-optimizer' ),
			)
		);

		add_settings_field(
			'wp_image_optimizer_enable_webp',
			__( 'Enable WebP Conversion', 'wp-image-optimizer' ),
			array( $this, 'renderCheckboxField' ),
			'wp_image_optimizer',
			'wp_image_optimizer_general',
			array(
				'id'          => 'enable_webp',
				'description' => __( 'Convert images to WebP format', 'wp-image-optimizer' ),
			)
		);

		add_settings_field(
			'wp_image_optimizer_enable_avif',
			__( 'Enable AVIF Conversion', 'wp-image-optimizer' ),
			array( $this, 'renderCheckboxField' ),
			'wp_image_optimizer',
			'wp_image_optimizer_general',
			array(
				'id'          => 'enable_avif',
				'description' => __( 'Convert images to AVIF format', 'wp-image-optimizer' ),
			)
		);

		// WebP settings section
		add_settings_section(
			'wp_image_optimizer_webp',
			__( 'WebP Settings', 'wp-image-optimizer' ),
			array( $this, 'renderWebpSection' ),
			'wp_image_optimizer'
		);

		add_settings_field(
			'wp_image_optimizer_webp_quality',
			__( 'WebP Quality', 'wp-image-optimizer' ),
			array( $this, 'renderRangeField' ),
			'wp_image_optimizer',
			'wp_image_optimizer_webp',
			array(
				'id'          => 'webp_quality',
				'min'         => 1,
				'max'         => 100,
				'step'        => 1,
				'description' => __( 'Quality of WebP images (1-100). Higher values mean better quality but larger file size.', 'wp-image-optimizer' ),
			)
		);

		add_settings_field(
			'wp_image_optimizer_webp_lossless',
			__( 'WebP Lossless', 'wp-image-optimizer' ),
			array( $this, 'renderCheckboxField' ),
			'wp_image_optimizer',
			'wp_image_optimizer_webp',
			array(
				'id'          => 'webp_lossless',
				'description' => __( 'Use lossless compression for WebP images. Results in larger file sizes but no quality loss.', 'wp-image-optimizer' ),
			)
		);

		// AVIF settings section
		add_settings_section(
			'wp_image_optimizer_avif',
			__( 'AVIF Settings', 'wp-image-optimizer' ),
			array( $this, 'renderAvifSection' ),
			'wp_image_optimizer'
		);

		add_settings_field(
			'wp_image_optimizer_avif_quality',
			__( 'AVIF Quality', 'wp-image-optimizer' ),
			array( $this, 'renderRangeField' ),
			'wp_image_optimizer',
			'wp_image_optimizer_avif',
			array(
				'id'          => 'avif_quality',
				'min'         => 1,
				'max'         => 100,
				'step'        => 1,
				'description' => __( 'Quality of AVIF images (1-100). Higher values mean better quality but larger file size.', 'wp-image-optimizer' ),
			)
		);

		add_settings_field(
			'wp_image_optimizer_avif_speed',
			__( 'AVIF Encoding Speed', 'wp-image-optimizer' ),
			array( $this, 'renderRangeField' ),
			'wp_image_optimizer',
			'wp_image_optimizer_avif',
			array(
				'id'          => 'avif_speed',
				'min'         => 0,
				'max'         => 10,
				'step'        => 1,
				'description' => __( 'Speed of AVIF encoding (0-10). Lower values mean better quality but slower encoding.', 'wp-image-optimizer' ),
			)
		);

		add_settings_field(
			'wp_image_optimizer_avif_lossless',
			__( 'AVIF Lossless', 'wp-image-optimizer' ),
			array( $this, 'renderCheckboxField' ),
			'wp_image_optimizer',
			'wp_image_optimizer_avif',
			array(
				'id'          => 'avif_lossless',
				'description' => __( 'Use lossless compression for AVIF images. Results in larger file sizes but no quality loss.', 'wp-image-optimizer' ),
			)
		);

		// Performance settings section
		add_settings_section(
			'wp_image_optimizer_performance',
			__( 'Performance Settings', 'wp-image-optimizer' ),
			array( $this, 'renderPerformanceSection' ),
			'wp_image_optimizer'
		);

		add_settings_field(
			'wp_image_optimizer_bulk_batch_size',
			__( 'Bulk Conversion Batch Size', 'wp-image-optimizer' ),
			array( $this, 'renderNumberField' ),
			'wp_image_optimizer',
			'wp_image_optimizer_performance',
			array(
				'id'          => 'bulk_batch_size',
				'min'         => 1,
				'max'         => 50,
				'description' => __( 'Number of images to process in each batch during bulk conversion. Lower values reduce server load.', 'wp-image-optimizer' ),
			)
		);

		add_settings_field(
			'wp_image_optimizer_processing_delay',
			__( 'Batch Processing Delay', 'wp-image-optimizer' ),
			array( $this, 'renderNumberField' ),
			'wp_image_optimizer',
			'wp_image_optimizer_performance',
			array(
				'id'          => 'processing_delay',
				'min'         => 0,
				'max'         => 1000,
				'description' => __( 'Delay in milliseconds between batch processing. Higher values reduce server load.', 'wp-image-optimizer' ),
			)
		);

		// Advanced settings section
		add_settings_section(
			'wp_image_optimizer_advanced',
			__( 'Advanced Settings', 'wp-image-optimizer' ),
			array( $this, 'renderAdvancedSection' ),
			'wp_image_optimizer'
		);

		add_settings_field(
			'wp_image_optimizer_conversion_method',
			__( 'Conversion Method', 'wp-image-optimizer' ),
			array( $this, 'renderSelectField' ),
			'wp_image_optimizer',
			'wp_image_optimizer_advanced',
			array(
				'id'          => 'conversion_method',
				'options'     => array(
					'auto'    => __( 'Auto (use best available)', 'wp-image-optimizer' ),
					'gd'      => __( 'GD Library', 'wp-image-optimizer' ),
					'imagick' => __( 'ImageMagick', 'wp-image-optimizer' ),
					'exec'    => __( 'Command Line Tools', 'wp-image-optimizer' ),
				),
				'description' => __( 'Method to use for image conversion. Auto will select the best available method.', 'wp-image-optimizer' ),
			)
		);
	}

	/**
	 * Enqueue admin assets
	 */
	public function enqueueAssets( string $hook ): void {
		if ( $hook !== 'settings_page_wp-image-optimizer' ) {
			return;
		}

		wp_enqueue_style(
			'wp-image-optimizer-admin',
			WP_IMAGE_OPTIMIZER_URL . 'assets/css/admin.css',
			array(),
			WP_IMAGE_OPTIMIZER_VERSION
		);

		wp_enqueue_script(
			'wp-image-optimizer-admin',
			WP_IMAGE_OPTIMIZER_URL . 'assets/js/admin.js',
			array( 'jquery' ),
			WP_IMAGE_OPTIMIZER_VERSION,
			true
		);

		wp_localize_script(
			'wp-image-optimizer-admin',
			'wpImageOptimizer',
			array(
				'ajax_url' => admin_url( 'admin-ajax.php' ),
				'nonce'    => wp_create_nonce( 'wp-image-optimizer' ),
				'i18n'     => array(
					'converting' => __( 'Converting...', 'wp-image-optimizer' ),
					'converted'  => __( 'Converted', 'wp-image-optimizer' ),
					'error'      => __( 'Error', 'wp-image-optimizer' ),
				),
			)
		);
	}

	/**
	 * Render settings page
	 */
	public function renderSettingsPage(): void {
		if ( ! current_user_can( 'manage_options' ) ) {
			return;
		}

		$active_tab = $_GET['tab'] ?? 'settings';
		?>
		<div class="wrap">
			<h1><?php echo esc_html( get_admin_page_title() ); ?></h1>
			
			<h2 class="nav-tab-wrapper">
				<a href="?page=wp-image-optimizer&tab=settings" class="nav-tab <?php echo $active_tab === 'settings' ? 'nav-tab-active' : ''; ?>">
					<?php _e( 'Settings', 'wp-image-optimizer' ); ?>
				</a>
				<a href="?page=wp-image-optimizer&tab=bulk" class="nav-tab <?php echo $active_tab === 'bulk' ? 'nav-tab-active' : ''; ?>">
					<?php _e( 'Bulk Convert', 'wp-image-optimizer' ); ?>
				</a>
				<a href="?page=wp-image-optimizer&tab=statistics" class="nav-tab <?php echo $active_tab === 'statistics' ? 'nav-tab-active' : ''; ?>">
					<?php _e( 'Statistics', 'wp-image-optimizer' ); ?>
				</a>
			</h2>
			
			<div class="tab-content">
				<?php
				if ( $active_tab === 'settings' ) {
					$this->renderSettingsTab();
				} elseif ( $active_tab === 'bulk' ) {
					$this->renderBulkTab();
				} elseif ( $active_tab === 'statistics' ) {
					$this->renderStatisticsTab();
				}
				?>
			</div>
		</div>
		<?php
	}

	/**
	 * Render settings tab
	 */
	private function renderSettingsTab(): void {
		?>
		<form action="options.php" method="post">
			<?php
			settings_fields( 'wp_image_optimizer_settings' );
			do_settings_sections( 'wp_image_optimizer' );
			submit_button();
			?>
		</form>
		<?php
	}

	/**
	 * Render bulk tab
	 */
	private function renderBulkTab(): void {
		$supportedCount = $this->stats->getSupportedFilesCount();
		?>
		<div class="wp-image-optimizer-bulk">
			<h2><?php _e( 'Bulk Convert Images', 'wp-image-optimizer' ); ?></h2>
			<p><?php printf( __( 'Found %d images that can be converted to WebP and AVIF formats.', 'wp-image-optimizer' ), $supportedCount ); ?></p>
			
			<div class="wp-image-optimizer-progress-wrapper" style="display:none;">
				<div class="wp-image-optimizer-progress">
					<div class="wp-image-optimizer-progress-bar"></div>
				</div>
				<div class="wp-image-optimizer-progress-text">
					<span class="wp-image-optimizer-progress-percentage">0%</span>
					<span class="wp-image-optimizer-progress-count">(0/<?php echo $supportedCount; ?>)</span>
				</div>
			</div>
			
			<p>
				<button type="button" class="button button-primary wp-image-optimizer-bulk-convert">
					<?php _e( 'Start Bulk Conversion', 'wp-image-optimizer' ); ?>
				</button>
			</p>
		</div>
		<?php
	}

	/**
	 * Render statistics tab
	 */
	private function renderStatisticsTab(): void {
		$stats      = $this->stats->countConvertedImages();
		$spaceSaved = $this->stats->calculateSpaceSaved();
		?>
		<div class="wp-image-optimizer-statistics">
			<h2><?php _e( 'Statistics', 'wp-image-optimizer' ); ?></h2>
			
			<table class="widefat striped">
				<thead>
					<tr>
						<th><?php _e( 'Metric', 'wp-image-optimizer' ); ?></th>
						<th><?php _e( 'Value', 'wp-image-optimizer' ); ?></th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td><?php _e( 'Total Images', 'wp-image-optimizer' ); ?></td>
						<td><?php echo $stats['total']; ?></td>
					</tr>
					<tr>
						<td><?php _e( 'Images with WebP Version', 'wp-image-optimizer' ); ?></td>
						<td><?php echo $stats['webp']; ?> (<?php echo $stats['total'] > 0 ? round( ( $stats['webp'] / $stats['total'] ) * 100, 2 ) : 0; ?>%)</td>
					</tr>
					<tr>
						<td><?php _e( 'Images with AVIF Version', 'wp-image-optimizer' ); ?></td>
						<td><?php echo $stats['avif']; ?> (<?php echo $stats['total'] > 0 ? round( ( $stats['avif'] / $stats['total'] ) * 100, 2 ) : 0; ?>%)</td>
					</tr>
					<tr>
						<td><?php _e( 'Images with Both Versions', 'wp-image-optimizer' ); ?></td>
						<td><?php echo $stats['both']; ?> (<?php echo $stats['total'] > 0 ? round( ( $stats['both'] / $stats['total'] ) * 100, 2 ) : 0; ?>%)</td>
					</tr>
					<tr>
						<td><?php _e( 'Original Size', 'wp-image-optimizer' ); ?></td>
						<td><?php echo size_format( $spaceSaved['original_size'] ); ?></td>
					</tr>
					<tr>
						<td><?php _e( 'WebP Size', 'wp-image-optimizer' ); ?></td>
						<td><?php echo size_format( $spaceSaved['webp_size'] ); ?></td>
					</tr>
					<tr>
						<td><?php _e( 'AVIF Size', 'wp-image-optimizer' ); ?></td>
						<td><?php echo size_format( $spaceSaved['avif_size'] ); ?></td>
					</tr>
					<tr>
						<td><?php _e( 'Total Space Saved', 'wp-image-optimizer' ); ?></td>
						<td><?php echo size_format( $spaceSaved['total_saved'] ); ?> (<?php echo $spaceSaved['percentage_saved']; ?>%)</td>
					</tr>
				</tbody>
			</table>
		</div>
		<?php
	}

	/**
	 * Section callbacks
	 */
	public function renderGeneralSection(): void {
		echo '<p>' . __( 'General settings for WebP & AVIF image optimization.', 'wp-image-optimizer' ) . '</p>';
	}

	public function renderWebpSection(): void {
		echo '<p>' . __( 'Settings for WebP image conversion.', 'wp-image-optimizer' ) . '</p>';
	}

	public function renderAvifSection(): void {
		echo '<p>' . __( 'Settings for AVIF image conversion.', 'wp-image-optimizer' ) . '</p>';
	}

	public function renderPerformanceSection(): void {
		echo '<p>' . __( 'Settings that affect conversion performance and server load.', 'wp-image-optimizer' ) . '</p>';
	}

	public function renderAdvancedSection(): void {
		echo '<p>' . __( 'Advanced settings for WebP & AVIF image optimization.', 'wp-image-optimizer' ) . '</p>';
	}

	/**
	 * Field renderers
	 */
	public function renderCheckboxField( array $args ): void {
		$id          = $args['id'];
		$description = $args['description'] ?? '';
		$value       = $this->settings->get( $id );
		?>
		<label>
			<input type="checkbox" name="wp_image_optimizer_settings[<?php echo esc_attr( $id ); ?>]" value="1" <?php checked( $value, true ); ?>>
			<?php echo esc_html( $description ); ?>
		</label>
		<?php
	}

	public function renderRangeField( array $args ): void {
		$id          = $args['id'];
		$min         = $args['min'] ?? 0;
		$max         = $args['max'] ?? 100;
		$step        = $args['step'] ?? 1;
		$description = $args['description'] ?? '';
		$value       = $this->settings->get( $id );
		?>
		<div class="wp-image-optimizer-range-field">
			<input type="range" name="wp_image_optimizer_settings[<?php echo esc_attr( $id ); ?>]" id="<?php echo esc_attr( $id ); ?>" min="<?php echo esc_attr( $min ); ?>" max="<?php echo esc_attr( $max ); ?>" step="<?php echo esc_attr( $step ); ?>" value="<?php echo esc_attr( $value ); ?>">
			<span class="wp-image-optimizer-range-value"><?php echo esc_html( $value ); ?></span>
		</div>
		<p class="description"><?php echo esc_html( $description ); ?></p>
		<script>
			jQuery(document).ready(function($) {
				$('#<?php echo esc_attr( $id ); ?>').on('input', function() {
					$(this).next('.wp-image-optimizer-range-value').text($(this).val());
				});
			});
		</script>
		<?php
	}

	public function renderNumberField( array $args ): void {
		$id          = $args['id'];
		$min         = $args['min'] ?? 0;
		$max         = $args['max'] ?? 100;
		$description = $args['description'] ?? '';
		$value       = $this->settings->get( $id );
		?>
		<input type="number" name="wp_image_optimizer_settings[<?php echo esc_attr( $id ); ?>]" id="<?php echo esc_attr( $id ); ?>" min="<?php echo esc_attr( $min ); ?>" max="<?php echo esc_attr( $max ); ?>" value="<?php echo esc_attr( $value ); ?>">
		<p class="description"><?php echo esc_html( $description ); ?></p>
		<?php
	}

	public function renderSelectField( array $args ): void {
		$id          = $args['id'];
		$options     = $args['options'] ?? array();
		$description = $args['description'] ?? '';
		$value       = $this->settings->get( $id );
		?>
		<select name="wp_image_optimizer_settings[<?php echo esc_attr( $id ); ?>]" id="<?php echo esc_attr( $id ); ?>">
			<?php foreach ( $options as $option_value => $option_label ) : ?>
				<option value="<?php echo esc_attr( $option_value ); ?>" <?php selected( $value, $option_value ); ?>>
					<?php echo esc_html( $option_label ); ?>
				</option>
			<?php endforeach; ?>
		</select>
		<p class="description"><?php echo esc_html( $description ); ?></p>
		<?php
	}

	/**
	 * Ajax handlers
	 */
	public function ajaxGetProgress(): void {
		check_ajax_referer( 'wp-image-optimizer', 'nonce' );

		if ( ! current_user_can( 'manage_options' ) ) {
			wp_send_json_error( array( 'message' => 'Insufficient permissions' ) );
		}

		$process_id = $_POST['process_id'] ?? '';
		if ( ! $process_id ) {
			wp_send_json_error( array( 'message' => 'Missing process ID' ) );
		}

		$progress = $this->progressManager->getProgress( $process_id );
		if ( ! $progress ) {
			wp_send_json_error( array( 'message' => 'Process not found' ) );
		}

		wp_send_json_success( $progress );
	}

	public function ajaxConvertSingle(): void {
		check_ajax_referer( 'wp-image-optimizer', 'nonce' );

		if ( ! current_user_can( 'upload_files' ) ) {
			wp_send_json_error( array( 'message' => 'Insufficient permissions' ) );
		}

		$attachment_id = (int) ( $_POST['attachment_id'] ?? 0 );
		if ( ! $attachment_id ) {
			wp_send_json_error( array( 'message' => 'Missing attachment ID' ) );
		}

		$mediaProcessor = new \WpImageOptimizer\Media\MediaProcessor(
			$this->container->get( 'webp_converter' ),
			$this->container->get( 'avif_converter' ),
			$this->settings,
			$this->progressManager,
			$this->logger
		);

		$result = $mediaProcessor->convertSingleImage( $attachment_id );

		if ( $result['success'] ) {
			wp_send_json_success(
				array(
					'message' => __( 'Image converted successfully', 'wp-image-optimizer' ),
					'webp'    => $result['webp'],
					'avif'    => $result['avif'],
				)
			);
		} else {
			wp_send_json_error( array( 'message' => __( 'Failed to convert image', 'wp-image-optimizer' ) ) );
		}
	}

	public function ajaxBulkConvert(): void {
		check_ajax_referer( 'wp-image-optimizer', 'nonce' );

		if ( ! current_user_can( 'manage_options' ) ) {
			wp_send_json_error( array( 'message' => 'Insufficient permissions' ) );
		}

		global $wpdb;

		// Get all image attachments
		$attachments = $wpdb->get_results(
			"SELECT ID FROM {$wpdb->posts} 
            WHERE post_type = 'attachment' 
            AND post_mime_type IN ('image/jpeg', 'image/png')"
		);

		$ids = array_map(
			function ( $attachment ) {
				return (int) $attachment->ID;
			},
			$attachments
		);

		// Generate a unique process ID
		$process_id = 'bulk_convert_' . uniqid();

		// Start a background process
		$mediaProcessor = new \WpImageOptimizer\Media\MediaProcessor(
			$this->container->get( 'webp_converter' ),
			$this->container->get( 'avif_converter' ),
			$this->settings,
			$this->progressManager,
			$this->logger
		);

		// Start the process
		$mediaProcessor->bulkConvertImages( $ids );

		wp_send_json_success(
			array(
				'message'    => __( 'Bulk conversion started', 'wp-image-optimizer' ),
				'process_id' => $process_id,
				'total'      => count( $ids ),
			)
		);
	}
}

================
File: src/Admin/DashboardWidget.php
================
<?php

namespace WpImageOptimizer\Admin;

use WpImageOptimizer\Utility\Stats;

class DashboardWidget {
	public function __construct(
		private Stats $stats
	) {}

	/**
	 * Register hooks for dashboard widget
	 */
	public function registerHooks(): void {
		add_action( 'wp_dashboard_setup', array( $this, 'addDashboardWidget' ) );
	}

	/**
	 * Add dashboard widget
	 */
	public function addDashboardWidget(): void {
		if ( current_user_can( 'manage_options' ) ) {
			wp_add_dashboard_widget(
				'wp_image_optimizer_dashboard_widget',
				__( 'WebP & AVIF Optimizer', 'wp-image-optimizer' ),
				array( $this, 'renderDashboardWidget' )
			);
		}
	}

	/**
	 * Render dashboard widget
	 */
	public function renderDashboardWidget(): void {
		$stats      = $this->stats->countConvertedImages();
		$spaceSaved = $this->stats->calculateSpaceSaved();

		?>
		<div class="wp-image-optimizer-dashboard-widget">
			<div class="wp-image-optimizer-dashboard-stats">
				<div class="wp-image-optimizer-stat-box">
					<span class="wp-image-optimizer-stat-label"><?php _e( 'Total Images', 'wp-image-optimizer' ); ?></span>
					<span class="wp-image-optimizer-stat-value"><?php echo $stats['total']; ?></span>
				</div>
				
				<div class="wp-image-optimizer-stat-box">
					<span class="wp-image-optimizer-stat-label"><?php _e( 'Optimized Images', 'wp-image-optimizer' ); ?></span>
					<span class="wp-image-optimizer-stat-value">
						<?php echo $stats['webp'] + $stats['avif'] - $stats['both']; ?>
						(<?php echo $stats['total'] > 0 ? round( ( ( $stats['webp'] + $stats['avif'] - $stats['both'] ) / $stats['total'] ) * 100, 2 ) : 0; ?>%)
					</span>
				</div>
				
				<div class="wp-image-optimizer-stat-box">
					<span class="wp-image-optimizer-stat-label"><?php _e( 'Space Saved', 'wp-image-optimizer' ); ?></span>
					<span class="wp-image-optimizer-stat-value">
						<?php echo size_format( $spaceSaved['total_saved'] ); ?>
						(<?php echo $spaceSaved['percentage_saved']; ?>%)
					</span>
				</div>
				
				<div class="wp-image-optimizer-stat-box">
					<span class="wp-image-optimizer-stat-label"><?php _e( 'Remaining Images', 'wp-image-optimizer' ); ?></span>
					<span class="wp-image-optimizer-stat-value">
						<?php echo $stats['total'] - ( $stats['webp'] + $stats['avif'] - $stats['both'] ); ?>
					</span>
				</div>
			</div>
			
			<div class="wp-image-optimizer-dashboard-actions">
				<a href="<?php echo admin_url( 'options-general.php?page=wp-image-optimizer&tab=bulk' ); ?>" class="button button-primary">
					<?php _e( 'Bulk Optimize Now', 'wp-image-optimizer' ); ?>
				</a>
				
				<a href="<?php echo admin_url( 'options-general.php?page=wp-image-optimizer&tab=statistics' ); ?>" class="button">
					<?php _e( 'View Detailed Stats', 'wp-image-optimizer' ); ?>
				</a>
			</div>
		</div>
		<?php
	}
}

================
File: src/Conversion/AvifConverter.php
================
<?php

namespace WpImageOptimizer\Conversion;

use WpImageOptimizer\Core\Settings;
use WpImageOptimizer\Utility\Logger;

class AvifConverter implements ConverterInterface {
	public function __construct(
		private Settings $settings,
		private Logger $logger
	) {}

	/**
	 * {@inheritdoc}
	 */
	public function convert( string $sourcePath, string $destinationPath, array $options = array() ): bool {
		// Merge with default settings
		$options = array_merge(
			array(
				'quality'  => $this->settings->get( 'avif_quality', 65 ),
				'speed'    => $this->settings->get( 'avif_speed', 6 ),
				'lossless' => $this->settings->get( 'avif_lossless', false ),
			),
			$options
		);

		// Try conversion methods in order of preference
		foreach ( $this->getEnabledMethods() as $method ) {
			try {
				$success = match ( $method ) {
					'gd' => $this->convertWithGd( $sourcePath, $destinationPath, $options ),
					'imagick' => $this->convertWithImagick( $sourcePath, $destinationPath, $options ),
					'avifenc' => $this->convertWithAvifenc( $sourcePath, $destinationPath, $options ),
					default => false,
				};

				if ( $success ) {
					$this->logger->info(
						"Successfully converted to AVIF using $method",
						array(
							'source'      => $sourcePath,
							'destination' => $destinationPath,
							'size_before' => filesize( $sourcePath ),
							'size_after'  => filesize( $destinationPath ),
						)
					);
					return true;
				}
			} catch ( \Exception $e ) {
				$this->logger->error(
					"AVIF conversion failed with $method: " . $e->getMessage(),
					array(
						'source' => $sourcePath,
						'method' => $method,
					)
				);
			}
		}

		$this->logger->error(
			'All AVIF conversion methods failed',
			array(
				'source' => $sourcePath,
			)
		);

		return false;
	}

	/**
	 * {@inheritdoc}
	 */
	public function isSupported(): bool {
		return count( $this->getAvailableMethods() ) > 0;
	}

	/**
	 * Get available conversion methods
	 *
	 * @return array List of available methods
	 */
	private function getAvailableMethods(): array {
		$methods = array();

		// Check GD
		if ( function_exists( 'imageavif' ) ) {
			$methods[] = 'gd';
		}

		// Check ImageMagick
		if ( class_exists( 'Imagick' ) &&
			defined( 'Imagick::COMPRESSION_JBIG2' ) && // Proxy check for AVIF support
			method_exists( 'Imagick', 'setCompressionQuality' ) ) {
			$methods[] = 'imagick';
		}

		// Check avifenc command-line
		if ( $this->isExecAvailable() && $this->isAvifencAvailable() ) {
			$methods[] = 'avifenc';
		}

		return $methods;
	}

	/**
	 * Get enabled conversion methods
	 *
	 * @return array List of enabled methods
	 */
	private function getEnabledMethods(): array {
		$preferred = $this->settings->get( 'avif_conversion_method', 'auto' );
		$available = $this->getAvailableMethods();

		// If specific method is selected and available, use only that
		if ( $preferred !== 'auto' && in_array( $preferred, $available ) ) {
			return array( $preferred );
		}

		// Otherwise use all available methods in order of quality
		return $available;
	}

	/**
	 * Convert using GD library
	 */
	private function convertWithGd( string $sourcePath, string $destinationPath, array $options ): bool {
		// Get image dimensions and type
		$imageInfo = getimagesize( $sourcePath );
		if ( ! $imageInfo ) {
			throw new \RuntimeException( "Failed to get image info for: $sourcePath" );
		}

		// Create source image based on type
		$sourceImage = match ( $imageInfo[2] ) {
			IMAGETYPE_JPEG => imagecreatefromjpeg( $sourcePath ),
			IMAGETYPE_PNG => imagecreatefrompng( $sourcePath ),
			IMAGETYPE_GIF => imagecreatefromgif( $sourcePath ),
			IMAGETYPE_WEBP => imagecreatefromwebp( $sourcePath ),
			default => throw new \RuntimeException( "Unsupported image type: {$imageInfo[2]}" ),
		};

		if ( ! $sourceImage ) {
			throw new \RuntimeException( 'Failed to create source image' );
		}

		// Preserve transparency for PNG
		if ( $imageInfo[2] === IMAGETYPE_PNG ) {
			imagepalettetotruecolor( $sourceImage );
			imagealphablending( $sourceImage, true );
			imagesavealpha( $sourceImage, true );
		}

		// Convert to AVIF
		$quality = $options['lossless'] ? 100 : $options['quality'];
		$speed   = $options['speed'] ?? 6; // Lower is better quality but slower

		// Set AVIF encoding options
		imagepalettetotruecolor( $sourceImage );

		// Save as AVIF
		$success = imageavif( $sourceImage, $destinationPath, $quality, $speed );

		// Free memory
		imagedestroy( $sourceImage );

		return $success;
	}

	/**
	 * Convert using ImageMagick
	 */
	private function convertWithImagick( string $sourcePath, string $destinationPath, array $options ): bool {
		$imagick = new \Imagick();
		$imagick->readImage( $sourcePath );

		// Handle transparency for PNG
		if ( pathinfo( $sourcePath, PATHINFO_EXTENSION ) === 'png' ) {
			$imagick->setImageFormat( 'png' );
			$imagick->setImageAlphaChannel( \Imagick::ALPHACHANNEL_ACTIVATE );
			$imagick->setBackgroundColor( new \ImagickPixel( 'transparent' ) );
		}

		// Set AVIF options
		$imagick->setImageFormat( 'avif' );

		if ( $options['lossless'] ) {
			$imagick->setImageCompressionQuality( 100 );
			$imagick->setOption( 'avif:lossless', 'true' );
		} else {
			$imagick->setImageCompressionQuality( $options['quality'] );
		}

		// Set speed
		$imagick->setOption( 'avif:speed', (string) $options['speed'] );

		// Write the image
		$success = $imagick->writeImage( $destinationPath );
		$imagick->clear();

		return $success;
	}

	/**
	 * Convert using avifenc command-line tool
	 */
	private function convertWithAvifenc( string $sourcePath, string $destinationPath, array $options ): bool {
		$quality  = $options['quality'];
		$speed    = $options['speed'];
		$lossless = $options['lossless'] ? '-l' : '';

		$command   = "avifenc {$lossless} -s {$speed} -q {$quality} \"{$sourcePath}\" \"{$destinationPath}\"";
		$output    = array();
		$returnVar = 0;

		exec( $command, $output, $returnVar );

		if ( $returnVar !== 0 ) {
			throw new \RuntimeException( "avifenc failed with code $returnVar: " . implode( "\n", $output ) );
		}

		return file_exists( $destinationPath ) && filesize( $destinationPath ) > 0;
	}

	/**
	 * Check if exec() function is available
	 */
	private function isExecAvailable(): bool {
		return function_exists( 'exec' ) &&
				! in_array( 'exec', explode( ',', ini_get( 'disable_functions' ) ) ) &&
				strtolower( ini_get( 'safe_mode' ) ) !== 'on';
	}

	/**
	 * Check if avifenc command-line tool is available
	 */
	private function isAvifencAvailable(): bool {
		if ( ! $this->isExecAvailable() ) {
			return false;
		}

		$output    = array();
		$returnVar = 0;

		exec( 'which avifenc', $output, $returnVar );

		return $returnVar === 0;
	}
}

================
File: src/Conversion/ConverterInterface.php
================
<?php

namespace WpImageOptimizer\Conversion;

interface ConverterInterface {
	/**
	 * Convert an image file to the target format
	 *
	 * @param string $sourcePath Path to the source image
	 * @param string $destinationPath Path to save the converted image
	 * @param array  $options Conversion options
	 * @return bool Success or failure
	 */
	public function convert( string $sourcePath, string $destinationPath, array $options = array() ): bool;

	/**
	 * Check if this converter is supported in the current environment
	 *
	 * @return bool Whether conversion is supported
	 */
	public function isSupported(): bool;
}

================
File: src/Conversion/WebpConverter.php
================
<?php

namespace WpImageOptimizer\Conversion;

use WpImageOptimizer\Core\Settings;
use WpImageOptimizer\Utility\Logger;

class WebpConverter implements ConverterInterface {
	public function __construct(
		private Settings $settings,
		private Logger $logger
	) {}

	/**
	 * {@inheritdoc}
	 */
	public function convert( string $sourcePath, string $destinationPath, array $options = array() ): bool {
		// Merge with default settings
		$options = array_merge(
			array(
				'quality'  => $this->settings->get( 'webp_quality' ),
				'lossless' => $this->settings->get( 'webp_lossless' ),
			),
			$options
		);

		// Try conversion methods in order of preference
		foreach ( $this->getEnabledMethods() as $method ) {
			try {
				$success = match ( $method ) {
					'gd' => $this->convertWithGd( $sourcePath, $destinationPath, $options ),
					'imagick' => $this->convertWithImagick( $sourcePath, $destinationPath, $options ),
					'cwebp' => $this->convertWithCwebp( $sourcePath, $destinationPath, $options ),
					default => false,
				};

				if ( $success ) {
					$this->logger->info(
						"Successfully converted to WebP using $method",
						array(
							'source'      => $sourcePath,
							'destination' => $destinationPath,
							'size_before' => filesize( $sourcePath ),
							'size_after'  => filesize( $destinationPath ),
						)
					);
					return true;
				}
			} catch ( \Exception $e ) {
				$this->logger->error(
					"WebP conversion failed with $method: " . $e->getMessage(),
					array(
						'source' => $sourcePath,
						'method' => $method,
					)
				);
			}
		}

		$this->logger->error(
			'All WebP conversion methods failed',
			array(
				'source' => $sourcePath,
			)
		);

		return false;
	}

	/**
	 * {@inheritdoc}
	 */
	public function isSupported(): bool {
		return count( $this->getAvailableMethods() ) > 0;
	}

	/**
	 * Get available conversion methods
	 *
	 * @return array List of available methods
	 */
	private function getAvailableMethods(): array {
		$methods = array();

		// Check GD
		if ( function_exists( 'imagewebp' ) ) {
			$methods[] = 'gd';
		}

		// Check ImageMagick
		if ( class_exists( 'Imagick' ) &&
			method_exists( 'Imagick', 'setImageFormat' ) &&
			defined( 'Imagick::COMPRESSION_JPEG' ) ) {
			$methods[] = 'imagick';
		}

		// Check cwebp command-line
		if ( $this->isExecAvailable() && $this->isCwebpAvailable() ) {
			$methods[] = 'cwebp';
		}

		return $methods;
	}

	/**
	 * Get enabled conversion methods
	 *
	 * @return array List of enabled methods
	 */
	private function getEnabledMethods(): array {
		$preferred = $this->settings->get( 'conversion_method', 'auto' );
		$available = $this->getAvailableMethods();

		// If specific method is selected and available, use only that
		if ( $preferred !== 'auto' && in_array( $preferred, $available ) ) {
			return array( $preferred );
		}

		// Otherwise use all available methods in order of quality
		return $available;
	}

	/**
	 * Convert using GD library
	 */
	private function convertWithGd( string $sourcePath, string $destinationPath, array $options ): bool {
		// Get image dimensions and type
		$imageInfo = getimagesize( $sourcePath );
		if ( ! $imageInfo ) {
			throw new \RuntimeException( "Failed to get image info for: $sourcePath" );
		}

		// Create source image based on type
		$sourceImage = match ( $imageInfo[2] ) {
			IMAGETYPE_JPEG => imagecreatefromjpeg( $sourcePath ),
			IMAGETYPE_PNG => imagecreatefrompng( $sourcePath ),
			IMAGETYPE_GIF => imagecreatefromgif( $sourcePath ),
			default => throw new \RuntimeException( "Unsupported image type: {$imageInfo[2]}" ),
		};

		if ( ! $sourceImage ) {
			throw new \RuntimeException( 'Failed to create source image' );
		}

		// Preserve transparency for PNG
		if ( $imageInfo[2] === IMAGETYPE_PNG ) {
			imagepalettetotruecolor( $sourceImage );
			imagealphablending( $sourceImage, true );
			imagesavealpha( $sourceImage, true );
		}

		// Convert to WebP
		$quality = $options['lossless'] ? 100 : $options['quality'];

		// Save as WebP
		$success = imagewebp( $sourceImage, $destinationPath, $quality );

		// Free memory
		imagedestroy( $sourceImage );

		return $success;
	}

	/**
	 * Convert using ImageMagick
	 */
	private function convertWithImagick( string $sourcePath, string $destinationPath, array $options ): bool {
		$imagick = new \Imagick();
		$imagick->readImage( $sourcePath );

		// Handle transparency for PNG
		if ( pathinfo( $sourcePath, PATHINFO_EXTENSION ) === 'png' ) {
			$imagick->setImageFormat( 'png' );
			$imagick->setImageAlphaChannel( \Imagick::ALPHACHANNEL_ACTIVATE );
			$imagick->setBackgroundColor( new \ImagickPixel( 'transparent' ) );
		}

		// Set WebP options
		$imagick->setImageFormat( 'webp' );

		if ( $options['lossless'] ) {
			$imagick->setImageCompressionQuality( 100 );
			$imagick->setOption( 'webp:lossless', 'true' );
		} else {
			$imagick->setImageCompressionQuality( $options['quality'] );
		}

		// Write the image
		$success = $imagick->writeImage( $destinationPath );
		$imagick->clear();

		return $success;
	}

	/**
	 * Convert using cwebp command-line tool
	 */
	private function convertWithCwebp( string $sourcePath, string $destinationPath, array $options ): bool {
		$quality  = $options['quality'];
		$lossless = $options['lossless'] ? '-lossless' : '';

		$command   = "cwebp {$lossless} -q {$quality} \"{$sourcePath}\" -o \"{$destinationPath}\"";
		$output    = array();
		$returnVar = 0;

		exec( $command, $output, $returnVar );

		if ( $returnVar !== 0 ) {
			throw new \RuntimeException( "cwebp failed with code $returnVar: " . implode( "\n", $output ) );
		}

		return file_exists( $destinationPath ) && filesize( $destinationPath ) > 0;
	}

	/**
	 * Check if exec() function is available
	 */
	private function isExecAvailable(): bool {
		return function_exists( 'exec' ) &&
				! in_array( 'exec', explode( ',', ini_get( 'disable_functions' ) ) ) &&
				strtolower( ini_get( 'safe_mode' ) ) !== 'on';
	}

	/**
	 * Check if cwebp command-line tool is available
	 */
	private function isCwebpAvailable(): bool {
		if ( ! $this->isExecAvailable() ) {
			return false;
		}

		$output    = array();
		$returnVar = 0;

		exec( 'which cwebp', $output, $returnVar );

		return $returnVar === 0;
	}
}

================
File: src/Core/Container.php
================
<?php

namespace WpImageOptimizer\Core;

class Container {
	private array $services  = array();
	private array $instances = array();

	/**
	 * Register a service with the container
	 */
	public function set( string $id, callable $factory ): void {
		$this->services[ $id ] = $factory;
		unset( $this->instances[ $id ] );
	}

	/**
	 * Get a service from the container
	 */
	public function get( string $id ) {
		if ( ! isset( $this->instances[ $id ] ) ) {
			if ( ! isset( $this->services[ $id ] ) ) {
				throw new \InvalidArgumentException( "Service not found: $id" );
			}
			$this->instances[ $id ] = ( $this->services[ $id ] )( $this );
		}
		return $this->instances[ $id ];
	}

	/**
	 * Check if a service exists in the container
	 */
	public function has( string $id ): bool {
		return isset( $this->services[ $id ] );
	}
}

================
File: src/Core/Plugin.php
================
<?php

namespace WpImageOptimizer\Core;

class Plugin {
	public function __construct(
		private Container $container
	) {}

	/**
	 * Bootstrap the plugin
	 */
	public function boot(): void {
		register_activation_hook( WP_IMAGE_OPTIMIZER_FILE, array( $this, 'activate' ) );
		register_deactivation_hook( WP_IMAGE_OPTIMIZER_FILE, array( $this, 'deactivate' ) );

		add_action( 'plugins_loaded', array( $this, 'init' ) );
	}

	/**
	 * Plugin activation hook
	 */
	public function activate(): void {
		// Check for minimum PHP version
		if ( version_compare( PHP_VERSION, '8.1', '<' ) ) {
			deactivate_plugins( plugin_basename( WP_IMAGE_OPTIMIZER_FILE ) );
			wp_die( 'WebP & AVIF Optimizer requires PHP 8.1 or higher.' );
		}

		// Initialize settings with defaults
		$settings = $this->container->get( 'settings' );
		$settings->initDefaults();

		// Add capabilities
		$this->addCapabilities();

		// Log activation
		$logger = $this->container->get( 'logger' );
		$logger->info( 'Plugin activated', array( 'version' => WP_IMAGE_OPTIMIZER_VERSION ) );
	}

	/**
	 * Plugin deactivation hook
	 */
	public function deactivate(): void {
		// Clean up temporary data
		$this->cleanupTemporaryData();

		// Log deactivation
		$logger = $this->container->get( 'logger' );
		$logger->info( 'Plugin deactivated' );
	}

	/**
	 * Initialize the plugin after WordPress is loaded
	 */
	public function init(): void {
		// Load text domain for translations
		load_plugin_textdomain( 'wp-image-optimizer', false, dirname( plugin_basename( WP_IMAGE_OPTIMIZER_FILE ) ) . '/languages' );

		// Register hooks for all services
		$this->container->get( 'admin_page' )->registerHooks();
		$this->container->get( 'media_library_integration' )->registerHooks();
		$this->container->get( 'dashboard_widget' )->registerHooks();
		$this->container->get( 'image_delivery' )->registerHooks();

		// Hook into WordPress upload process
		add_filter( 'wp_handle_upload', array( $this->container->get( 'media_processor' ), 'processUploadedMedia' ) );
	}

	/**
	 * Add plugin capabilities to roles
	 */
	private function addCapabilities(): void {
		$admin = get_role( 'administrator' );
		if ( $admin ) {
			$admin->add_cap( 'manage_webp_avif_optimizer' );
		}
	}

	/**
	 * Clean up temporary data on deactivation
	 */
	private function cleanupTemporaryData(): void {
		global $wpdb;

		// Delete all transients
		$wpdb->query( "DELETE FROM $wpdb->options WHERE option_name LIKE '%_transient_wp_image_optimizer_%'" );
	}
}

================
File: src/Core/Settings.php
================
<?php

namespace WpImageOptimizer\Core;

class Settings {
	private const OPTION_KEY = 'wp_image_optimizer_settings';

	private array $defaults = array(
		// General settings
		'auto_convert'      => true,
		'enable_webp'       => true,
		'enable_avif'       => true,

		// WebP settings
		'webp_quality'      => 80,
		'webp_lossless'     => false,

		// AVIF settings
		'avif_quality'      => 65,
		'avif_speed'        => 6,
		'avif_lossless'     => false,

		// Performance settings
		'bulk_batch_size'   => 10,
		'processing_delay'  => 250, // milliseconds

		// Advanced settings
		'conversion_method' => 'auto', // auto, gd, imagick, or exec
	);

	private ?array $settings = null;

	/**
	 * Get a setting value
	 */
	public function get( string $key, $default = null ) {
		$this->loadIfNeeded();
		return $this->settings[ $key ] ?? ( $default ?? $this->defaults[ $key ] ?? null );
	}

	/**
	 * Set a setting value
	 */
	public function set( string $key, $value ): void {
		$this->loadIfNeeded();
		$this->settings[ $key ] = $value;
		$this->save();
	}

	/**
	 * Get all settings
	 */
	public function getAll(): array {
		$this->loadIfNeeded();
		return $this->settings;
	}

	/**
	 * Initialize default settings
	 */
	public function initDefaults(): void {
		$saved = get_option( self::OPTION_KEY, array() );
		if ( empty( $saved ) ) {
			update_option( self::OPTION_KEY, $this->defaults );
		}
	}

	/**
	 * Load settings from database if not already loaded
	 */
	private function loadIfNeeded(): void {
		if ( $this->settings === null ) {
			$saved          = get_option( self::OPTION_KEY, array() );
			$this->settings = array_merge( $this->defaults, $saved );
		}
	}

	/**
	 * Save settings to database
	 */
	private function save(): void {
		update_option( self::OPTION_KEY, $this->settings );
	}
}

================
File: src/Frontend/ImageDelivery.php
================
<?php

namespace WpImageOptimizer\Frontend;

use WpImageOptimizer\Core\Settings;

class ImageDelivery {
	public function __construct(
		private Settings $settings
	) {}

	/**
	 * Register hooks for frontend image delivery
	 */
	public function registerHooks(): void {
		// Only apply filters if the feature is enabled
		if ( $this->settings->get( 'enable_frontend_delivery', true ) ) {
			// Filter content to replace img tags
			add_filter( 'the_content', array( $this, 'replaceImgTags' ) );

			// Filter post thumbnails
			add_filter( 'post_thumbnail_html', array( $this, 'replaceImgTags' ) );

			// Add support for custom image HTML
			add_filter( 'wp_get_attachment_image', array( $this, 'replaceImgTags' ) );
		}
	}

	/**
	 * Replace img tags with picture tags for WebP/AVIF support
	 */
	public function replaceImgTags( string $content ): string {
		// Skip if the content doesn't contain img tags
		if ( strpos( $content, '<img' ) === false ) {
			return $content;
		}

		// Regular expression to find img tags
		$pattern = '/<img([^>]+)>/i';

		// Replace img tags with picture tags
		$content = preg_replace_callback( $pattern, array( $this, 'replaceSingleImgTag' ), $content );

		return $content;
	}

	/**
	 * Replace a single img tag with a picture tag
	 */
	private function replaceSingleImgTag( array $matches ): string {
		// Extract attributes from the img tag
		$img_tag   = $matches[0];
		$img_attrs = $matches[1];

		// Extract src attribute
		if ( ! preg_match( '/src=["\'](https?:\/\/[^"\']+)["\']/', $img_attrs, $src_matches ) ) {
			return $img_tag; // No src attribute found, return original tag
		}

		$src = $src_matches[1];

		// Skip if not a local image or not from the uploads directory
		$uploads_url = wp_upload_dir()['baseurl'];
		if ( strpos( $src, $uploads_url ) !== 0 ) {
			return $img_tag;
		}

		// Get attachment ID from URL
		$attachment_id = $this->getAttachmentIdFromUrl( $src );
		if ( ! $attachment_id ) {
			return $img_tag;
		}

		// Get WebP and AVIF versions
		$meta = wp_get_attachment_metadata( $attachment_id );
		if ( ! $meta ) {
			return $img_tag;
		}

		$webp_url = $meta['webp_url'] ?? null;
		$avif_url = $meta['avif_url'] ?? null;

		// Return original tag if no optimized versions found
		if ( ! $webp_url && ! $avif_url ) {
			return $img_tag;
		}

		// Build picture tag
		$picture = '<picture>';

		// Add AVIF source if available
		if ( $avif_url ) {
			$picture .= '<source srcset="' . esc_attr( $avif_url ) . '" type="image/avif">';
		}

		// Add WebP source if available
		if ( $webp_url ) {
			$picture .= '<source srcset="' . esc_attr( $webp_url ) . '" type="image/webp">';
		}

		// Add original img tag
		$picture .= $img_tag;
		$picture .= '</picture>';

		return $picture;
	}

	/**
	 * Get attachment ID from URL
	 */
	private function getAttachmentIdFromUrl( string $url ): ?int {
		global $wpdb;

		$uploads_dir = wp_upload_dir();
		$base_url    = $uploads_dir['baseurl'];

		// Remove the base URL to get the relative path
		$relative_path = str_replace( $base_url, '', $url );

		// Find attachment by relative path
		$attachment_id = $wpdb->get_var(
			$wpdb->prepare(
				"SELECT post_id FROM $wpdb->postmeta WHERE meta_key = '_wp_attached_file' AND meta_value = %s",
				ltrim( $relative_path, '/' )
			)
		);

		return $attachment_id ? (int) $attachment_id : null;
	}
}

================
File: src/Media/MediaLibraryIntegration.php
================
<?php

namespace WpImageOptimizer\Media;

use WpImageOptimizer\Core\Settings;

class MediaLibraryIntegration {
	public function __construct(
		private Settings $settings,
		private MediaProcessor $mediaProcessor
	) {}

	/**
	 * Register hooks for media library integration
	 */
	public function registerHooks(): void {
		// Add convert button to media library
		add_filter( 'attachment_fields_to_edit', array( $this, 'addConvertButtons' ), 10, 2 );

		// Add status column to media library
		add_filter( 'manage_media_columns', array( $this, 'addStatusColumn' ) );
		add_action( 'manage_media_custom_column', array( $this, 'renderStatusColumn' ), 10, 2 );

		// Filter media items by conversion status
		add_action( 'pre_get_posts', array( $this, 'filterMediaItems' ) );

		// Add bulk action
		add_filter( 'bulk_actions-upload', array( $this, 'addBulkActions' ) );
		add_filter( 'handle_bulk_actions-upload', array( $this, 'handleBulkActions' ), 10, 3 );

		// Add admin notices
		add_action( 'admin_notices', array( $this, 'showAdminNotices' ) );
	}

	/**
	 * Add convert buttons to media modal
	 */
	public function addConvertButtons( array $form_fields, object $post ): array {
		// Only show for supported image types
		if ( ! $this->isSupportedImageType( $post->post_mime_type ) ) {
			return $form_fields;
		}

		$meta    = wp_get_attachment_metadata( $post->ID );
		$hasWebp = ! empty( $meta['webp_path'] ) && file_exists( $meta['webp_path'] );
		$hasAvif = ! empty( $meta['avif_path'] ) && file_exists( $meta['avif_path'] );

		// Add convert button
		$form_fields['wp_image_optimizer'] = array(
			'label' => __( 'WebP & AVIF', 'wp-image-optimizer' ),
			'input' => 'html',
			'html'  => $this->getConversionButtonsHtml( $post->ID, $hasWebp, $hasAvif ),
		);

		return $form_fields;
	}

	/**
	 * Add status column to media library
	 */
	public function addStatusColumn( array $columns ): array {
		$columns['wp_image_optimizer'] = __( 'WebP & AVIF', 'wp-image-optimizer' );
		return $columns;
	}

	/**
	 * Render status column in media library
	 */
	public function renderStatusColumn( string $column_name, int $post_id ): void {
		if ( $column_name !== 'wp_image_optimizer' ) {
			return;
		}

		$post = get_post( $post_id );

		// Only show for supported image types
		if ( ! $this->isSupportedImageType( $post->post_mime_type ) ) {
			echo '<span class="dashicons dashicons-minus"></span>';
			return;
		}

		$meta    = wp_get_attachment_metadata( $post_id );
		$hasWebp = ! empty( $meta['webp_path'] ) && file_exists( $meta['webp_path'] );
		$hasAvif = ! empty( $meta['avif_path'] ) && file_exists( $meta['avif_path'] );

		if ( $hasWebp && $hasAvif ) {
			echo '<span class="dashicons dashicons-yes-alt" style="color:green;" title="' . esc_attr__( 'Both WebP and AVIF versions available', 'wp-image-optimizer' ) . '"></span>';
		} elseif ( $hasWebp ) {
			echo '<span class="dashicons dashicons-yes" style="color:orange;" title="' . esc_attr__( 'WebP version available', 'wp-image-optimizer' ) . '"></span>';
		} elseif ( $hasAvif ) {
			echo '<span class="dashicons dashicons-yes" style="color:blue;" title="' . esc_attr__( 'AVIF version available', 'wp-image-optimizer' ) . '"></span>';
		} else {
			echo '<span class="dashicons dashicons-no" style="color:red;" title="' . esc_attr__( 'No optimized versions available', 'wp-image-optimizer' ) . '"></span>';
		}
	}

	/**
	 * Filter media items by conversion status
	 */
	public function filterMediaItems( \WP_Query $query ): void {
		if ( ! is_admin() || ! $query->is_main_query() || ! function_exists( 'get_current_screen' ) ) {
			return;
		}

		$screen = get_current_screen();
		if ( ! $screen || $screen->base !== 'upload' ) {
			return;
		}

		$status = $_GET['wp_image_optimizer_status'] ?? '';
		if ( ! $status ) {
			return;
		}

		// Add filter to the meta query
		$meta_query = $query->get( 'meta_query', array() );

		switch ( $status ) {
			case 'has_webp':
				$meta_query[] = array(
					'key'     => '_wp_attachment_metadata',
					'value'   => 'webp_path',
					'compare' => 'LIKE',
				);
				break;

			case 'has_avif':
				$meta_query[] = array(
					'key'     => '_wp_attachment_metadata',
					'value'   => 'avif_path',
					'compare' => 'LIKE',
				);
				break;

			case 'has_none':
				$meta_query[] = array(
					'relation' => 'AND',
					array(
						'key'     => '_wp_attachment_metadata',
						'value'   => 'webp_path',
						'compare' => 'NOT LIKE',
					),
					array(
						'key'     => '_wp_attachment_metadata',
						'value'   => 'avif_path',
						'compare' => 'NOT LIKE',
					),
				);
				break;
		}

		$query->set( 'meta_query', $meta_query );
	}

	/**
	 * Add bulk actions to media library
	 */
	public function addBulkActions( array $bulk_actions ): array {
		$bulk_actions['wp_image_optimizer_convert'] = __( 'Convert to WebP & AVIF', 'wp-image-optimizer' );
		return $bulk_actions;
	}

	/**
	 * Handle bulk actions
	 */
	public function handleBulkActions( string $redirect_to, string $doaction, array $post_ids ): string {
		if ( $doaction !== 'wp_image_optimizer_convert' ) {
			return $redirect_to;
		}

		// Filter to supported image types
		$supported_ids = array();
		foreach ( $post_ids as $post_id ) {
			$post = get_post( $post_id );
			if ( $post && $this->isSupportedImageType( $post->post_mime_type ) ) {
				$supported_ids[] = $post_id;
			}
		}

		// Start bulk conversion in the background
		$this->mediaProcessor->bulkConvertImages( $supported_ids );

		// Add query args for admin notice
		$redirect_to = add_query_arg(
			'wp_image_optimizer_bulk_converted',
			count( $supported_ids ),
			$redirect_to
		);

		return $redirect_to;
	}

	/**
	 * Show admin notices
	 */
	public function showAdminNotices(): void {
		if ( ! is_admin() || ! function_exists( 'get_current_screen' ) ) {
			return;
		}

		$screen = get_current_screen();
		if ( ! $screen || $screen->base !== 'upload' ) {
			return;
		}

		// Show bulk conversion notice
		$converted = $_GET['wp_image_optimizer_bulk_converted'] ?? 0;
		if ( $converted ) {
			echo '<div class="notice notice-success is-dismissible"><p>';
			printf(
				__( 'Started conversion of %d images to WebP and AVIF formats. This process runs in the background.', 'wp-image-optimizer' ),
				$converted
			);
			echo '</p></div>';
		}
	}

	/**
	 * Get HTML for conversion buttons
	 */
	private function getConversionButtonsHtml( int $attachment_id, bool $has_webp, bool $has_avif ): string {
		$html = '<div class="wp-image-optimizer-buttons">';

		// WebP status
		$html .= '<div class="wp-image-optimizer-status">';
		$html .= '<span class="wp-image-optimizer-webp">';
		$html .= '<strong>WebP:</strong> ';
		if ( $has_webp ) {
			$html .= '<span class="dashicons dashicons-yes" style="color:green;"></span>';
		} else {
			$html .= '<span class="dashicons dashicons-no" style="color:red;"></span>';
		}
		$html .= '</span> ';

		// AVIF status
		$html .= '<span class="wp-image-optimizer-avif">';
		$html .= '<strong>AVIF:</strong> ';
		if ( $has_avif ) {
			$html .= '<span class="dashicons dashicons-yes" style="color:green;"></span>';
		} else {
			$html .= '<span class="dashicons dashicons-no" style="color:red;"></span>';
		}
		$html .= '</span>';
		$html .= '</div>';

		// Convert button
		$html .= '<button type="button" class="button wp-image-optimizer-convert" data-id="' . esc_attr( $attachment_id ) . '">';
		$html .= '<span class="spinner" style="float:none;margin-top:0;"></span> ';
		$html .= __( 'Convert Now', 'wp-image-optimizer' );
		$html .= '</button>';

		$html .= '</div>';

		return $html;
	}

	/**
	 * Check if a MIME type is a supported image type
	 */
	private function isSupportedImageType( string $mime_type ): bool {
		return in_array( $mime_type, array( 'image/jpeg', 'image/png' ) );
	}
}

================
File: src/Media/MediaProcessor.php
================
<?php

namespace WpImageOptimizer\Media;

use WpImageOptimizer\Conversion\ConverterInterface;
use WpImageOptimizer\Core\Settings;
use WpImageOptimizer\Utility\ProgressManager;
use WpImageOptimizer\Utility\Logger;

class MediaProcessor {
	public function __construct(
		private ConverterInterface $webpConverter,
		private ConverterInterface $avifConverter,
		private Settings $settings,
		private ProgressManager $progressManager,
		private Logger $logger
	) {}

	/**
	 * Process image on upload
	 */
	public function processUploadedMedia( array $upload ): array {
		// Skip processing if auto-convert is disabled
		if ( ! $this->settings->get( 'auto_convert', true ) ) {
			return $upload;
		}

		// Check if the file is a supported image type
		if ( ! $this->isSupportedImage( $upload['file'] ) ) {
			return $upload;
		}

		$attachmentId = $this->getAttachmentIdByUrl( $upload['url'] );
		if ( ! $attachmentId ) {
			return $upload;
		}

		// Convert to WebP if enabled
		if ( $this->settings->get( 'enable_webp', true ) && $this->webpConverter->isSupported() ) {
			$this->convertToFormat( $attachmentId, 'webp' );
		}

		// Convert to AVIF if enabled
		if ( $this->settings->get( 'enable_avif', true ) && $this->avifConverter->isSupported() ) {
			$this->convertToFormat( $attachmentId, 'avif' );
		}

		return $upload;
	}

	/**
	 * Convert a single image by attachment ID
	 */
	public function convertSingleImage( int $attachmentId ): array {
		$result = array(
			'success' => false,
			'webp'    => false,
			'avif'    => false,
		);

		$file = get_attached_file( $attachmentId );
		if ( ! $file || ! $this->isSupportedImage( $file ) ) {
			return $result;
		}

		if ( $this->settings->get( 'enable_webp', true ) && $this->webpConverter->isSupported() ) {
			$result['webp'] = $this->convertToFormat( $attachmentId, 'webp' );
		}

		if ( $this->settings->get( 'enable_avif', true ) && $this->avifConverter->isSupported() ) {
			$result['avif'] = $this->convertToFormat( $attachmentId, 'avif' );
		}

		$result['success'] = $result['webp'] || $result['avif'];

		return $result;
	}

	/**
	 * Bulk convert multiple images
	 */
	public function bulkConvertImages( array $ids ): void {
		$totalImages = count( $ids );
		$processId   = 'bulk_convert_' . uniqid();

		// Initialize progress tracking
		$this->progressManager->startProcess( $processId, $totalImages );
		$this->logger->info( "Starting bulk conversion of $totalImages images", array( 'process_id' => $processId ) );

		// Process in batches to prevent timeouts
		$batchSize = (int) $this->settings->get( 'bulk_batch_size', 10 );
		$batches   = array_chunk( $ids, $batchSize );

		foreach ( $batches as $index => $batch ) {
			// Process each image in the batch
			foreach ( $batch as $batchIndex => $attachmentId ) {
				$result    = $this->convertSingleImage( $attachmentId );
				$processed = ( $index * $batchSize ) + $batchIndex + 1;

				$this->progressManager->updateProgress( $processId, $processed );

				$this->logger->info(
					"Processed image $processed/$totalImages",
					array(
						'attachment_id' => $attachmentId,
						'success'       => $result['success'],
						'webp'          => $result['webp'],
						'avif'          => $result['avif'],
					)
				);
			}

			// Allow a pause between batches to prevent server overload
			if ( $index < count( $batches ) - 1 ) {
				$delay = (int) $this->settings->get( 'processing_delay', 250 );
				usleep( $delay * 1000 ); // Convert to microseconds
			}
		}

		$this->logger->info( "Completed bulk conversion of $totalImages images", array( 'process_id' => $processId ) );
	}

	/**
	 * Convert an attachment to a specific format
	 */
	private function convertToFormat( int $attachmentId, string $format ): bool {
		$file = get_attached_file( $attachmentId );
		if ( ! $file ) {
			return false;
		}

		$destPath  = $this->getDestinationPath( $file, $format );
		$converter = $format === 'webp' ? $this->webpConverter : $this->avifConverter;

		$success = $converter->convert( $file, $destPath, array() );

		if ( $success ) {
			// Update attachment metadata
			$meta                     = wp_get_attachment_metadata( $attachmentId );
			$meta[ "{$format}_path" ] = $destPath;
			$meta[ "{$format}_url" ]  = $this->getWebUrl( $destPath );
			wp_update_attachment_metadata( $attachmentId, $meta );
		}

		return $success;
	}

	/**
	 * Get the destination path for a converted image
	 */
	private function getDestinationPath( string $sourcePath, string $format ): string {
		$pathInfo = pathinfo( $sourcePath );
		return $pathInfo['dirname'] . '/' . $pathInfo['filename'] . '.' . $format;
	}

	/**
	 * Get web URL for a file path
	 */
	private function getWebUrl( string $filePath ): string {
		$uploadsDir = wp_upload_dir();
		$baseDir    = $uploadsDir['basedir'];
		$baseUrl    = $uploadsDir['baseurl'];

		return str_replace( $baseDir, $baseUrl, $filePath );
	}

	/**
	 * Check if a file is a supported image type
	 */
	private function isSupportedImage( string $file ): bool {
		$supportedTypes = array( 'jpg', 'jpeg', 'png' );
		$extension      = strtolower( pathinfo( $file, PATHINFO_EXTENSION ) );
		return in_array( $extension, $supportedTypes );
	}

	/**
	 * Get attachment ID by URL
	 */
	private function getAttachmentIdByUrl( string $url ): ?int {
		global $wpdb;

		$uploadDir = wp_upload_dir();
		$baseUrl   = $uploadDir['baseurl'];

		// Remove the base URL to get the relative path
		$relativePath = str_replace( $baseUrl, '', $url );

		// Find attachment by relative path
		$attachmentId = $wpdb->get_var(
			$wpdb->prepare(
				"SELECT post_id FROM $wpdb->postmeta WHERE meta_key = '_wp_attached_file' AND meta_value = %s",
				ltrim( $relativePath, '/' )
			)
		);

		return $attachmentId ? (int) $attachmentId : null;
	}
}

================
File: src/Utility/Logger.php
================
<?php

namespace WpImageOptimizer\Utility;

class Logger {
	private const LOG_OPTION = 'wp_image_optimizer_logs';
	private const MAX_LOGS   = 100;

	/**
	 * Log an info message
	 */
	public function info( string $message, array $context = array() ): void {
		$this->log( 'info', $message, $context );
	}

	/**
	 * Log an error message
	 */
	public function error( string $message, array $context = array() ): void {
		$this->log( 'error', $message, $context );
	}

	/**
	 * Log a warning message
	 */
	public function warning( string $message, array $context = array() ): void {
		$this->log( 'warning', $message, $context );
	}

	/**
	 * Log a message
	 */
	private function log( string $level, string $message, array $context = array() ): void {
		$logs = get_option( self::LOG_OPTION, array() );

		// Add new log entry
		$logs[] = array(
			'level'     => $level,
			'message'   => $message,
			'context'   => $context,
			'timestamp' => time(),
		);

		// Limit log size
		if ( count( $logs ) > self::MAX_LOGS ) {
			$logs = array_slice( $logs, -self::MAX_LOGS );
		}

		update_option( self::LOG_OPTION, $logs );
	}

	/**
	 * Get all logs
	 */
	public function getLogs(): array {
		return get_option( self::LOG_OPTION, array() );
	}

	/**
	 * Clear all logs
	 */
	public function clearLogs(): void {
		delete_option( self::LOG_OPTION );
	}
}

================
File: src/Utility/ProgressManager.php
================
<?php

namespace WpImageOptimizer\Utility;

class ProgressManager {
	private const TRANSIENT_PREFIX = 'wp_image_optimizer_progress_';
	private const EXPIRATION       = 3600; // 1 hour

	/**
	 * Start a new progress tracking process
	 */
	public function startProcess( string $processId, int $total ): void {
		set_transient(
			self::TRANSIENT_PREFIX . $processId,
			array(
				'total'     => $total,
				'processed' => 0,
				'started'   => time(),
				'updated'   => time(),
			),
			self::EXPIRATION
		);
	}

	/**
	 * Update progress for a process
	 */
	public function updateProgress( string $processId, int $processed ): void {
		$progress = get_transient( self::TRANSIENT_PREFIX . $processId );
		if ( ! $progress ) {
			return;
		}

		$progress['processed'] = $processed;
		$progress['updated']   = time();

		set_transient( self::TRANSIENT_PREFIX . $processId, $progress, self::EXPIRATION );
	}

	/**
	 * Get progress for a process
	 */
	public function getProgress( string $processId ): ?array {
		$progress = get_transient( self::TRANSIENT_PREFIX . $processId );
		if ( ! $progress ) {
			return null;
		}

		$progress['percentage'] = ( $progress['total'] > 0 )
			? round( ( $progress['processed'] / $progress['total'] ) * 100 )
			: 0;

		return $progress;
	}

	/**
	 * Clear progress for a process
	 */
	public function clearProgress( string $processId ): void {
		delete_transient( self::TRANSIENT_PREFIX . $processId );
	}
}

================
File: src/Utility/Stats.php
================
<?php

namespace WpImageOptimizer\Utility;

class Stats {
	/**
	 * Count total number of images with WebP/AVIF versions
	 */
	public function countConvertedImages(): array {
		global $wpdb;

		$results = array(
			'total' => 0,
			'webp'  => 0,
			'avif'  => 0,
			'both'  => 0,
		);

		// Get all image attachments
		$imageAttachments = $wpdb->get_results(
			"SELECT ID, post_mime_type FROM {$wpdb->posts} 
            WHERE post_type = 'attachment' 
            AND post_mime_type LIKE 'image/%'
            AND post_mime_type NOT LIKE 'image/webp'
            AND post_mime_type NOT LIKE 'image/avif'"
		);

		$results['total'] = count( $imageAttachments );

		// Count conversions
		foreach ( $imageAttachments as $attachment ) {
			$meta = wp_get_attachment_metadata( $attachment->ID );

			$hasWebp = ! empty( $meta['webp_path'] ) && file_exists( $meta['webp_path'] );
			$hasAvif = ! empty( $meta['avif_path'] ) && file_exists( $meta['avif_path'] );

			if ( $hasWebp ) {
				++$results['webp'];
			}

			if ( $hasAvif ) {
				++$results['avif'];
			}

			if ( $hasWebp && $hasAvif ) {
				++$results['both'];
			}
		}

		return $results;
	}

	/**
	 * Calculate space saved by WebP/AVIF conversions
	 */
	public function calculateSpaceSaved(): array {
		global $wpdb;

		$results = array(
			'original_size'    => 0,
			'webp_size'        => 0,
			'avif_size'        => 0,
			'total_saved'      => 0,
			'percentage_saved' => 0,
		);

		// Get all image attachments
		$imageAttachments = $wpdb->get_results(
			"SELECT ID, post_mime_type FROM {$wpdb->posts} 
            WHERE post_type = 'attachment' 
            AND post_mime_type LIKE 'image/%'
            AND post_mime_type NOT LIKE 'image/webp'
            AND post_mime_type NOT LIKE 'image/avif'"
		);

		// Calculate sizes
		foreach ( $imageAttachments as $attachment ) {
			$meta         = wp_get_attachment_metadata( $attachment->ID );
			$originalFile = get_attached_file( $attachment->ID );

			if ( ! $originalFile || ! file_exists( $originalFile ) ) {
				continue;
			}

			$originalSize              = filesize( $originalFile );
			$results['original_size'] += $originalSize;

			// Check WebP
			if ( ! empty( $meta['webp_path'] ) && file_exists( $meta['webp_path'] ) ) {
				$webpSize              = filesize( $meta['webp_path'] );
				$results['webp_size'] += $webpSize;
			}

			// Check AVIF
			if ( ! empty( $meta['avif_path'] ) && file_exists( $meta['avif_path'] ) ) {
				$avifSize              = filesize( $meta['avif_path'] );
				$results['avif_size'] += $avifSize;
			}
		}

		// Calculate savings
		if ( $results['original_size'] > 0 ) {
			$smallestSize = min(
				$results['webp_size'] > 0 ? $results['webp_size'] : PHP_INT_MAX,
				$results['avif_size'] > 0 ? $results['avif_size'] : PHP_INT_MAX
			);

			if ( $smallestSize < PHP_INT_MAX ) {
				$results['total_saved']      = $results['original_size'] - $smallestSize;
				$results['percentage_saved'] = round( ( $results['total_saved'] / $results['original_size'] ) * 100, 2 );
			}
		}

		return $results;
	}

	/**
	 * Get count of supported image files in media library
	 */
	public function getSupportedFilesCount(): int {
		global $wpdb;

		return (int) $wpdb->get_var(
			"SELECT COUNT(*) FROM {$wpdb->posts} 
            WHERE post_type = 'attachment' 
            AND (
                post_mime_type LIKE 'image/jpeg' OR
                post_mime_type LIKE 'image/jpg' OR
                post_mime_type LIKE 'image/png'
            )"
		);
	}
}

================
File: src/Autoloader.php
================
<?php

namespace WpImageOptimizer;

class Autoloader {
	/**
	 * Register the autoloader
	 */
	public static function register(): void {
		spl_autoload_register( array( self::class, 'autoload' ) );
	}

	/**
	 * Autoload classes
	 */
	public static function autoload( string $class ): void {
		// Only handle our own namespace
		if ( strpos( $class, 'WpImageOptimizer\\' ) !== 0 ) {
			return;
		}

		// Convert namespace to file path
		$relative_class = substr( $class, strlen( 'WpImageOptimizer\\' ) );
		$file           = WP_IMAGE_OPTIMIZER_DIR . 'src/' . str_replace( '\\', '/', $relative_class ) . '.php';

		// Include the file if it exists
		if ( file_exists( $file ) ) {
			require_once $file;
		}
	}
}

================
File: .distignore
================
# Directories and files to exclude from distribution
.git
.github
.gitignore
.gitlab-ci.yml
.travis.yml
.DS_Store
.distignore
.editorconfig
.eslintignore
.eslintrc
.prettierrc
.prettierignore
.stylelintrc
.stylelintignore
.wordpress-org
composer.json
composer.lock
node_modules
package.json
package-lock.json
phpcs.xml
phpcs.xml.dist
phpunit.xml
phpunit.xml.dist
README.md
webpack.config.js
tests
bin
build
assets/js/src
assets/css/src

================
File: .htaccess
================
# Disable directory browsing
Options -Indexes

# Block direct access to PHP files
<FilesMatch "\.php$">
    # Apache 2.2
    <IfModule !mod_authz_core.c>
        Order deny,allow
        Deny from all
    </IfModule>
    
    # Apache 2.4+
    <IfModule mod_authz_core.c>
        Require all denied
    </IfModule>
</FilesMatch>

# Allow direct access to main plugin file
<Files "wp-image-optimizer.php">
    # Apache 2.2
    <IfModule !mod_authz_core.c>
        Order allow,deny
        Allow from all
    </IfModule>
    
    # Apache 2.4+
    <IfModule mod_authz_core.c>
        Require all granted
    </IfModule>
</Files>

# Deny access to potential sensitive files
<FilesMatch "^.*\.(log|json|lock|yml|xml|md|txt|sql)$">
    # Apache 2.2
    <IfModule !mod_authz_core.c>
        Order deny,allow
        Deny from all
    </IfModule>
    
    # Apache 2.4+
    <IfModule mod_authz_core.c>
        Require all denied
    </IfModule>
</FilesMatch>

================
File: CHANGELOG.md
================
# Changelog

All notable changes to the WebP & AVIF Image Optimizer plugin will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]

### Added
- Future features will be listed here

## [0.1.0] - 2025-03-20

### Added
- Initial plugin release
- WebP image conversion support
- AVIF image conversion support
- Automatic conversion on upload
- Bulk conversion tool
- Media library integration
- Statistics dashboard
- Settings page for customization

================
File: composer.json
================
{
    "name": "your-vendor/wp-image-optimizer",
    "description": "High-performance WebP and AVIF conversion for WordPress images",
    "type": "wordpress-plugin",
    "license": "GPL-2.0-or-later",
    "require": {
        "php": ">=8.1"
    },
    "require-dev": {
        "squizlabs/php_codesniffer": "^3.7",
        "wp-coding-standards/wpcs": "^2.3"
    },
    "autoload": {
        "psr-4": {
            "WpImageOptimizer\\": "src/"
        }
    },
    "scripts": {
        "check": [
            "@lint",
            "@phpstan",
            "@security"
        ],
        "check-strict": [
            "@lint",
            "@phpcs",
            "@phpstan",
            "@security"
        ],
        "fix": "@phpcbf",
        "lint": "find ./src -name '*.php' -print0 | xargs -0 -n1 php -l",
        "phpcs": "phpcs --standard=phpcs.xml.dist",
        "phpcbf": "phpcbf --standard=phpcs.xml.dist",
        "phpstan": "phpstan analyse || true",
        "security": "phpcs --standard=PHPCompatibility,PSR12 --extensions=php --runtime-set testVersion 8.1- src/ || true",
        "pre-commit": "@lint"
    },
    "require-dev": {
        "squizlabs/php_codesniffer": "^3.7",
        "wp-coding-standards/wpcs": "^2.3",
        "dealerdirect/phpcodesniffer-composer-installer": "^1.0",
        "phpstan/phpstan": "^1.10",
        "phpcompatibility/php-compatibility": "^9.3"
    },
    "config": {
        "allow-plugins": {
            "dealerdirect/phpcodesniffer-composer-installer": true
        }
    }
}

================
File: index.php
================
<?php
// Silence is golden.

================
File: phpcs.xml.dist
================
<?xml version="1.0"?>
<ruleset name="WordPress Plugin Coding Standards">
    <description>A custom set of code standard rules for WP Image Optimizer.</description>

    <!-- What to scan -->
    <file>.</file>
    
    <!-- Exclude patterns -->
    <exclude-pattern>/vendor/*</exclude-pattern>
    <exclude-pattern>/node_modules/*</exclude-pattern>
    <exclude-pattern>/assets/js/*</exclude-pattern>
    <exclude-pattern>/assets/css/*</exclude-pattern>
    <exclude-pattern>/build/*</exclude-pattern>
    <exclude-pattern>/.github/*</exclude-pattern>
    
    <!-- Ensure compatibility with modern PHP -->
    <config name="testVersion" value="8.1-"/>
    <config name="minimum_supported_wp_version" value="6.0"/>

    <!-- Use WordPress as a base -->
    <rule ref="WordPress">
        <!-- Rules to exclude -->
        <exclude name="WordPress.Files.FileName.InvalidClassFileName"/>
        <exclude name="WordPress.Files.FileName.NotHyphenatedLowercase"/>
        <exclude name="WordPress.NamingConventions.ValidVariableName.PropertyNotSnakeCase"/>
        <exclude name="WordPress.NamingConventions.ValidVariableName.UsedPropertyNotSnakeCase"/>
        <exclude name="WordPress.NamingConventions.ValidVariableName.VariableNotSnakeCase"/>
        <exclude name="WordPress.NamingConventions.ValidFunctionName.MethodNameInvalid"/>
        <exclude name="WordPress.NamingConventions.PrefixAllGlobals"/>
        <exclude name="WordPress.WP.I18n.MissingTranslatorsComment"/>
        <exclude name="Squiz.Commenting.FileComment.Missing"/>
        <exclude name="Squiz.Commenting.ClassComment.Missing"/>
        <exclude name="Squiz.Commenting.FunctionComment.Missing"/>
    </rule>

    <!-- Let's be a bit more permissive for a modern plugin -->
    <rule ref="Generic.Arrays.DisallowShortArraySyntax.Found">
        <severity>0</severity>
    </rule>
    
    <!-- Allow short array syntax -->
    <rule ref="Generic.Arrays.DisallowShortArraySyntax.Found">
        <severity>0</severity>
    </rule>
    
    <!-- Allow short ternary syntax -->
    <rule ref="Generic.CodeAnalysis.EmptyStatement.DetectedExpressionAfterTernary">
        <severity>0</severity>
    </rule>
    
    <!-- Allow modern PHP features -->
    <rule ref="Generic.PHP.DisallowShortOpenTag">
        <severity>0</severity>
    </rule>
    
    <rule ref="WordPress.PHP.YodaConditions">
        <severity>0</severity>
    </rule>
</ruleset>

================
File: phpstan.neon
================
parameters:
    level: 5
    paths:
        - src
    excludePaths:
        - vendor
        - node_modules
    ignoreErrors:
        # WordPress specific functions that PHPStan doesn't know about
        - '#Function [a-zA-Z0-9\\_]+ not found#'
        - '#Constant [A-Z_]+ not found#'
    checkMissingIterableValueType: false

================
File: README.md
================
# WordPress WebP & AVIF Image Optimizer

A high-performance WordPress plugin for converting and optimizing your images to WebP and AVIF formats.

## Features

- **Automatic Conversion**: Automatically convert uploaded images to WebP and AVIF formats
- **Manual Conversion**: Manually convert individual images from the media library
- **Bulk Conversion**: Convert your entire media library in the background
- **Format Detection**: Serve the appropriate format based on browser support
- **Performance Optimization**: High-performance image processing with minimal server impact
- **Detailed Statistics**: Track space savings and conversion rates
- **Flexible Settings**: Customize quality, conversion methods, and more

## Requirements

- WordPress 5.3+
- PHP 8.1+
- GD library with WebP/AVIF support, ImageMagick, or command-line tools

## Installation

1. Upload the `wp-image-optimizer` folder to the `/wp-content/plugins/` directory
2. Activate the plugin through the 'Plugins' menu in WordPress
3. Go to 'Settings > WebP & AVIF' to configure the plugin

## Development

### Setup Development Environment

1. Clone this repository
2. Install Composer dependencies: `composer install`
3. Install Git hooks for code quality checks: `./bin/install-git-hooks.sh`

### Code Quality & Security Checks

Different levels of code checking are available:

1. **Basic checks** (required before commits):
   ```
   composer lint
   ```
   Ensures PHP code doesn't contain syntax errors.

2. **Standard checks** (recommended during development):
   ```
   composer check
   ```
   Runs syntax checks, security checks and static analysis with relaxed rules.
   
3. **Strict checks** (same rules as CI):
   ```
   composer check-strict
   ```
   Runs all checks including strict coding standards.

### Fixing Code Style Issues

Fix automatically fixable coding standards issues with:

```
composer fix
```

Or use the comprehensive fixing script:

```
./bin/fix-code-style.sh
```

### Pre-commit Hooks

The pre-commit hook verifies PHP syntax and shows warnings for style issues but doesn't block commits. Install it with:

```
./bin/install-git-hooks.sh
```

## Usage

### Automatic Conversion

By default, the plugin will automatically convert newly uploaded JPEG and PNG images to WebP and AVIF formats. You can disable this in the settings.

### Manual Conversion

You can manually convert images from the media library by:

1. Clicking on an image in the media library
2. Clicking the "Convert Now" button in the WebP & AVIF section

### Bulk Conversion

To convert all your existing images:

1. Go to 'Settings > WebP & AVIF > Bulk Convert'
2. Click the "Start Bulk Conversion" button
3. Wait for the conversion to complete

### Format Detection

The plugin automatically detects browser support and serves the appropriate format (WebP, AVIF, or the original image).

## Advanced Configuration

### Quality Settings

You can adjust the quality of WebP and AVIF images in the settings. Higher values result in better image quality but larger file sizes.

### Conversion Methods

The plugin supports multiple conversion methods:

- **GD Library**: Fast, built-in PHP image processing
- **ImageMagick**: More advanced image processing
- **Command Line Tools**: Highest quality but requires server access

### Performance Tuning

You can adjust batch size and processing delay to balance conversion speed with server load.

## Troubleshooting

### Images Not Converting

- Make sure your server has the necessary libraries (GD with WebP/AVIF support or ImageMagick)
- Check that the images are in a supported format (JPEG or PNG)
- Verify that you have write permissions for the upload directory

### High Server Load

- Reduce the batch size in the performance settings
- Increase the processing delay between batches
- Consider converting images manually or during off-peak hours

## License

This plugin is licensed under the GPL v2 or later.

## Credits

- Developed by Your Name
- Uses the WebP and AVIF libraries

================
File: uninstall.php
================
<?php
/**
 * Uninstall script for WebP & AVIF Image Optimizer
 *
 * @package WpImageOptimizer
 */

// If uninstall not called from WordPress, exit
if ( ! defined( 'WP_UNINSTALL_PLUGIN' ) ) {
	exit;
}

// Delete plugin options
delete_option( 'wp_image_optimizer_settings' );
delete_option( 'wp_image_optimizer_logs' );

// Delete transients
global $wpdb;
$wpdb->query( "DELETE FROM $wpdb->options WHERE option_name LIKE '%_transient_wp_image_optimizer_%'" );

// Check if user wants to delete converted images
$delete_images = get_option( 'wp_image_optimizer_delete_on_uninstall', false );

if ( $delete_images ) {
	// Get all attachments with WebP/AVIF versions
	$attachments = $wpdb->get_results(
		"SELECT post_id, meta_value FROM $wpdb->postmeta 
        WHERE meta_key = '_wp_attachment_metadata' 
        AND (meta_value LIKE '%webp_path%' OR meta_value LIKE '%avif_path%')"
	);

	foreach ( $attachments as $attachment ) {
		// Get metadata
		$meta = maybe_unserialize( $attachment->meta_value );

		// Delete WebP file if exists
		if ( ! empty( $meta['webp_path'] ) && file_exists( $meta['webp_path'] ) ) {
			@unlink( $meta['webp_path'] );
		}

		// Delete AVIF file if exists
		if ( ! empty( $meta['avif_path'] ) && file_exists( $meta['avif_path'] ) ) {
			@unlink( $meta['avif_path'] );
		}

		// Remove WebP/AVIF info from metadata
		unset( $meta['webp_path'] );
		unset( $meta['webp_url'] );
		unset( $meta['avif_path'] );
		unset( $meta['avif_url'] );

		// Update metadata
		update_post_meta( $attachment->post_id, '_wp_attachment_metadata', $meta );
	}
}

// Remove capabilities
$admin = get_role( 'administrator' );
if ( $admin ) {
	$admin->remove_cap( 'manage_webp_avif_optimizer' );
}

================
File: wp-image-optimizer.php
================
<?php
/**
 * Plugin Name: WebP & AVIF Image Optimizer
 * Description: High-performance WebP and AVIF conversion for WordPress images
 * Version: 1.0.0
 * Author: Your Name
 * License: GPL v2 or later
 * Text Domain: wp-image-optimizer
 * Requires PHP: 8.1
 */

declare(strict_types=1);

if ( ! defined( 'ABSPATH' ) ) {
	exit;
}

define( 'WP_IMAGE_OPTIMIZER_VERSION', '1.0.0' );
define( 'WP_IMAGE_OPTIMIZER_FILE', __FILE__ );
define( 'WP_IMAGE_OPTIMIZER_DIR', plugin_dir_path( __FILE__ ) );
define( 'WP_IMAGE_OPTIMIZER_URL', plugin_dir_url( __FILE__ ) );

if ( file_exists( __DIR__ . '/vendor/autoload.php' ) ) {
	require_once __DIR__ . '/vendor/autoload.php';
} else {
	require_once __DIR__ . '/src/Autoloader.php';
	\WpImageOptimizer\Autoloader::register();
}

if ( ! defined( 'WP_IMAGE_OPTIMIZER_VERSION' ) ) {
	if ( is_dir( __DIR__ . '/.git' ) && function_exists( 'exec' ) ) {
		$git_tag = null;
		exec( 'git describe --tags --abbrev=0 2>&1', $output, $return_var );
		if ( $return_var === 0 && ! empty( $output[0] ) ) {
			$git_tag = trim( $output[0] );
			if ( substr( $git_tag, 0, 1 ) === 'v' ) {
				$git_tag = substr( $git_tag, 1 );
			}
		}

		define( 'WP_IMAGE_OPTIMIZER_VERSION', $git_tag ?: '1.0.0' );
	} else {
		define( 'WP_IMAGE_OPTIMIZER_VERSION', '1.0.0' );
	}
}

( function () {
	$container = new \WpImageOptimizer\Core\Container();

	require_once __DIR__ . '/config/services.php';

	$plugin = $container->get( 'plugin' );
	$plugin->boot();
} )();
